---
layout: page
title: Policy Manager Policy Handler Programming Guide
description: Provides information about the Akana Container Policy Handler Framework.
product: ag
category: ref
sub-nav-class: Policy Manager Programming
weight: 06
type: page
nav-title: Policy Handler Programming Guide (HTML)
---
<h1 id="top">Policy Handler Programming Guide</h1>
<p>This document provides information about the Akana Policy Handler Framework. It describes the architecture of the framework, the framework API, and how to deploy extensions to the framework.</p>
<p>To effectively use this guide, you should have access to and a working knowledge of the concepts outlined in the following Policy Manager product documentation:</p>
<ul>
	<li><a href="pm_message_handler_programming_guide.htm">Policy Manager Message Handler Programming Guide</a></li>
</ul>
<hr class="divide_hr" />



<h2 style="color: gray;">Table of Contents</h2>
<ol class="table_of_contents">
	<li><a href="#s01_architecture">Policy Handler Framework Architecture</a>
		<ul>
			<li><a href="#s01_01_overview">Overview</a></li>
			<li><a href="#s01_02_policies">Policies</a></li>
			<li><a href="#s01_03_marshallers">Marshallers</a></li>
			<li><a href="#s01_04_policy_handlers">Policy Handlers</a></li>
			<li><a href="#s01_05_policy_handler_factories">Policy Handler Factories</a></li>
			<li><a href="#s01_06_handler_chains">Handler Chains</a></li>
			<li><a href="#s01_07_framework_nd">The Framework in the Network Director Feature</a></li>
			</ul>
		</li>
	<li><a href="#s02_framework">Policy Handler Framework API</a>
		<ul>
			<li><a href="#s02_01_policy_api">Policy API</a></li>
			<li><a href="#s02_02_policy_handler_factory_api">Policy Handler Factory API</a></li>
		</ul>
		</li>
	
	<li><a href="#s03_deployment">Policy Handler Deployment</a></li>
	<li><a href="#s04_development">Developing a Policy Handler</a>
		<ul>
			<li><a href="#s04_01_schema">Policy Assertion Schema</a></li>
			<li><a href="#s04_02_source_code">Source Code</a></li>
			<li><a href="#s04_03_bundle">Bundle</a></li>
			<li><a href="#s04_4_deployment">Deployment</a></li>
			</ul>
	</li>
	<li><a href="#s05_references">References</a></li>
</ol>




<hr class="divide_hr" />




<h2 id="s01_architecture">Policy Handler Framework Architecture</h2>


<h3 id="s01_01_overview">Overview</h3>
<p>The Akana API Platform includes an extensible Policy Handler Framework for implementing and enforcing policies on messages. The Policy Handler Framework is an extension of the Message Handler Framework (see the <a href="pm_message_handler_programming_guide.htm">Policy Manager Message Handler Programming Guide</a>, specialized for runtime policies, both Operational and Quality of Service.</p>
<p>The Policy Handler framework provides a set of interfaces in addition to those provided by the Message Handler Framework that can be implemented by developers who would like to extend the base policy capabilities of the product, which are also implemented using the same framework.</p>
<p>The policy handler framework is used to process incoming and outgoing messages of web services. This processing is typically constrained to binding specific logic, header processing, security decisions, and minor transformations. It is not intended to provide orchestration, content-based routing, or major transformations. For those capabilities, use the Virtual Service Orchestration Framework.</p>
<p>The Policy Handler Framework is used by individual features such as the Network Director. The Network Director acts as a provider and consumer of services; in this scenario, the framework is used for processing both incoming and outgoing message exchanges.</p>
<p class="Note"><strong>Note</strong>: this document covers only Network Director use of the Policy Handler Framework.</p>
<p>The processing performed by the policy handler framework is dictated by policies attached to services in Policy Manager. Enforcement is the act of ensuring a policy is met by a message. Implementation is the act of altering a message so that it conforms to a policy. When the policy framework governs a service that is receiving messages, the framework enforces the policies attached to the service. It must also implement those same policies on messages that are returned to the client.</p>
<p>Example</p>
<p>For example, let's say service A has a security policy attached to it that dictates the request and response messages must be signed. The framework enforces that policy on the request message by:</p>
<ul>
	<li>Verifying that a signature is present on the request message.</li>
	<li>Verifying that the signature is valid.</li>
	<li>Implementing the policy on the response message by signing it before it is returned to the client.</li>
</ul>
<p>When the framework is used on the consumer side of a message exchange, it:</p>
<ol>
	<li>Implements the policies attached to the target service on the messages sent to the target.</li>
	<li>Enforces the same policies on the messages returned by the target.</li>
</ol>
<p>In the case of the Network Director feature, the policy framework is invoked twice:</p>
<ol>
	<li>Once for the exchange between the client and the virtual service.</li>
	<li>Once for the exchange between the virtual service and the target service.</li>
</ol>
<p>In all the features, the Policy Handler Framework is made up of the same fundamental components:</p>
<ul>
	<li><a href="#s01_02_policies">Policies</a></li>
	<li>Message Handlers</li>
	<li>Policy Handler Factories</li>
	<li><a href="#s01_06_handler_chains">Handler Chains</a></li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_02_policies">Policies</h3>
<p>Policies in Policy Manager are modeled according to the [WS-Policy] specification. This specification defines a policy as a set of assertions that can be grouped together in a conditional fashion using XML. An assertion is any XML element that represents enforceable or implementable rules.</p>
<p>Both the [WS-Policy] specification and Policy Manager support the notion of assertions themselves having their own policies, so that a nesting such as <strong>policy</strong> &gt; <strong>assertion</strong> &gt; <strong>policy</strong> &gt; <strong>assertion</strong> is possible.</p>
<p>The WS-Policy specification supports the notion of a policy containing choices of assertions at any level.</p>
<p>Policy Manager only support choices within policies that are contained within assertions, not directly within the root policy itself.</p>
<p>The specification is flexible about how policies can be constructed but it provides a single normal form that all policies can be converted to. That normal form is how Policy Manager represents all policies. The following is an example of a policy in Policy Manager:</p>
<pre>01) &lt;wsp:Policy Name="My Policy"&gt;
02)  &lt;wsp:ExactlyOne&gt;
03)    &lt;wsp:All&gt;
04)      &lt;MyAssertion&gt;
05)        &lt;wsp:Policy&gt;
06)          &lt;wsp:ExactlyOne&gt;
07)            &lt;wsp:All&gt;
08)              &lt;MyChoice1/&gt;
09)            &lt;/wsp:All&gt;
10)            &lt;wsp:All&gt;
11)              &lt;MyChoice2/&gt;
12)            &lt;/wsp:All&gt;
13)          &lt;/wsp:ExactlyOne&gt;
14)          &lt;/wsp:Policy&gt;
15)        &lt;/MyAssertion&gt;
16)      &lt;/wsp:All&gt;
17)    &lt;/wsp:ExactlyOne&gt;
18)  &lt;/wsp:Policy&gt;</pre>
<p>In the above:</p>
<ul>
	<li>Lines 01&#8211;18 represent a single policy named <strong>My Policy</strong>.</li>
	<li>On lines 04&#8211;15, the policy author has supplied an assertion named MyAssertion.</li>
	<li>MyAssertion provides two choices, MyChoice1 on line 8 and MyChoice2 on line 11. The use of the ExactlyOne element on line 6 delineates the choices.</li>
</ul>
<p>You can attach multiple policies to services and organizations in Policy Manager. You can also attach policies at different levels of the organization tree and different levels of the service definition. All the policies that apply to a given request or response message must be collected and combined so that they can be properly enforced or implemented. All these policies are combined into what is called an <strong>effective</strong> policy, or the complete set of assertions that apply to a given message. There will be an effective policy for each message (IN, OUT, FAULT) of each operation of each service being governed as described in a WSDL document.</p>
<p>To illustrate, a policy with MyAssertion1 is attached to a service in Policy Manager. Another policy with MyAssertion2 is attached to an operation of that service in Policy Manager. The effective policy for the operation would look like the below:</p>
<pre>01)  &lt;wsp:Policy Name="My Effective Policy"&gt;
02)    &lt;wsp:ExactlyOne&gt;
03)      &lt;wsp:All&gt;
04)        &lt;MyAssertion1/&gt;
05)        &lt;MyAssertion2/&gt;
06)      &lt;/wsp:All&gt;
07)    &lt;/wsp:ExactlyOne&gt;
08)  &lt;/wsp:Policy&gt;</pre>
<p>For more information about policy attachments (scopes) and <strong>effective</strong> policies, please consult the [WS-PolicyAttachment] specification.</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_03_marshallers">Marshallers</h3>
<p>The Policy Handler Framework receives policies from Policy Manager in the XML form described in the previous section. It parses the XML into a Java representation that can then be used by policy handlers to implement and enforce. The framework has a Java API that it parses the policy constructs (Policy, ExactlyOne, All) into, but it doesn't have an understanding of the assertions that policy authors write. Instead, it delegates the assertion interpretation to domain-specific implementations provided by the policy authors.</p>
<p>The policy author provides an Assertion Marshaller that parses the assertion XML into a Java representation. If a policy author does not have a domain-specific Java model for the assertion, the following alternatives are available:</p>
<ul>
	<li>Rely on built-in facilities to marshal the assertion into an <span class="apidoc_code">org.w3c.dom</span> (DOM) representation.</li>
	<li>Use other XML marshaling frameworks such as the <span class="apidoc_code">javax.xml.bind</span> (JAXB) API within a marshaller as well.</li>
	<li>Write proprietary parsing code.</li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_04_policy_handlers">Policy Handlers</h3>
<p>A Policy Handler is a Java class that is given a message from a message exchange to either implement or enforce a policy. A Policy Handler is actually just a Message Handler described in the <a href="pm_message_handler_programming_guide.htm">Policy Manager Message Handler Programming Guide</a>. The same Message Handler is used within the Policy Handler Framework. There are no differences between Message Handlers used in both frameworks. The differences are found in how the handlers are created through the use of factories.</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_05_policy_handler_factories">Policy Handler Factories</h3>
<p>A Policy (Message) Handler is constructed by a Policy Handler Factory. The framework will call a handler factory with context about the handler that should be created including the <strong>effective</strong> policy and the scope of the handler. Since an effective policy can be different for each message (IN, OUT, FAULT) of each operation of a service, the scope will be the exact message the effective policy is for. In other words, a handler is created for each message of each operation of a service.</p>
<p>If an operation has multiple faults defined in its WSDL document, the factory is called for each fault.</p>
<p>There is not a one-to-one relationship of policy to Policy Handler Factory or Policy Handler. Multiple factories and handlers can process a single policy. A single factory or handler can execute business logic based on multiple policies. Because each factory registered with the framework is called with the effective policy, it:</p>
<ul>
	<li>Has access to all the assertions present within that effective policy.</li>
	<li>Can read each assertion it understands.</li>
</ul>
<p>Example</p>
<p>For example, a policy P1 has some conditional rules that are enforced if another policy P2 has been attached to the same message. P2 has its own policy handler factory that interprets it. When building its handler, P1 must:</p>
<ul>
	<li>Interpret P1</li>
	<li>Check for the presence of P2</li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_06_handler_chains">Handler Chains</h3>
<p>As described in the <a href="pm_message_handler_programming_guide.htm">Policy Manager Message Handler Programming Guide</a>, a Handler Chain is a list of MessageHandlers that are invoked in order, each being given the same message as context. The Policy Handlers created from the Policy Handler Factories are put in one handler chain. The order of their execution is based on the order in which the factories were called.</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s01_07_framework_nd">The Framework in the Network Director Feature</h3>
<p>The Network Director acts as an intermediary, and therefore both a provider and consumer, so it includes several variations of binding and mediation support.</p>
<p><img src="images/pmphpgm_01_03.jpg" alt="Framework in the Network Director feature" /></p>
<p>The Network Director supports any number of bindings for both incoming and outgoing message exchanges.</p>
<p>Based on routing dictated by the Virtual Service engine, messages received on one binding may or may not be forwarded on to the downstream service using the same type of binding.</p>
<p>Every binding implementation is different. Third parties and customers themselves can implement their own bindings. Bindings developed by Akana all incorporate the Policy Handler Framework in a consistent fashion. The handlers created and invoked within the bindings may be different based on binding type, but the frameworks share a similar organization.</p>
<p>For IN bindings, each binding only deploys binding handlers that are specific to the matching type of binding in addition to all global handlers. In Network Director, the WS-Policy handlers are divided between the IN bindings and the Virtual Service Engine.</p>
<p>The Virtual Service Engine deploys all WS-Policy handlers for policies that are attached to the abstract WSDL components of a Service:</p>
<ul>
	<li>PortType</li>
	<li>PortType Operation</li>
	<li>Service</li>
</ul>
<p>The IN bindings deploy the WS-Policy handlers that are specific to the concrete WSDL components of a service:</p>
<ul>
	<li>Binding</li>
	<li>Binding Operation</li>
	<li>Port</li>
</ul>
<p>This enables virtual services to invoke other locally-deployed virtual services while still having policies enforced.</p>
<p><a href="#top">Back to top</a></p>



<h2 id="s02_framework">Policy Handler Framework API</h2>
<p>The Policy Handler Framework API is composed of three major groups of classes:</p>
<ul>
	<li><a href="#s02_01_policy_api">Policy API</a>: Provides interfaces and classes for defining policies, assertions, and assertion marshalling.</li>
	<li>Message Handler API: Provides the core interfaces and classes for Message Handlers and processing of message exchanges. Described in the <a href="pm_message_handler_programming_guide.htm">Policy Manager Message Handler Programming Guide</a>.</li>
	<li><a href="#s02_02_policy_handler_factory_api">Policy Handler Factory API</a>: Provides interfaces and classes for creating Message Handlers, but within the context of policy enforcement and implementation.</li>
</ul>
<p>The following sections provide a brief description of these interfaces and classes. A detailed description of the API is available in the \docs\apidocs folder of your Akana Platform release directory and on the Akana documentation site (go to <a href="../generated_docs/apidoc_restApiDocs.htm" title="Link to REST API docs on docs site" target="_blank">http://docs.akana.com/ag/apidoc_restApiDocs.htm</a> and choose the applicable version for your installation).</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s02_01_policy_api">Policy API</h3>
<p>The Policy API is composed of a small number of interfaces and classes that can be used to represent policies and assertions. These are all in the <span class="apidoc_code">com.soa.policy.wspolicy</span> package.</p>
<p><img src="images/pmphpgm_02_01.jpg" alt="Policy API" /></p>
<p>In the above:</p>
<ul>
	<li>The <span class="apidoc_code">Policy</span>, <span class="apidoc_code">ExactlyOne</span>, and <span class="apidoc_code">All</span> classes are WS-Policy constructs.</li>
	<li>The <span class="apidoc_code">Assertion</span> interface defines what all assertions must implement</li>
	<li>The <span class="apidoc_code">SubPolicyAssertion</span> interface is an <span class="apidoc_code">Assertion</span> extension for assertions that have nested policies of their own.</li>
</ul>
<p>The Policy API also provides:</p>
<ul>
	<li>An interface for assertion marshalling.</li>
	<li>Some pre-existing marshalling implementations.</li>
</ul>
<p><img src="images/pmphpgm_02_02.jpg" alt="Policy API" /></p>
<p>An assertion is represented in the framework with the <span class="apidoc_code">Assertion</span> interface. Assertion is the interface that all domain-specific representations must implement. A policy author can implement this interface directly with their own class, or they can use some of the existing implementations.</p>
<p>For example, <span class="apidoc_code">XmlAssertion</span> provides a default DOM representation of an assertion. <span class="apidoc_code">JavaAssertion</span> provides an implementation that simply wraps an existing Java object. This is useful when the author wants an assertion class that does not have to implement the Assertion interface, such as when they are using JAXB to model an assertion.</p>
<p>Policy authors instruct the framework how an assertion must be parsed by registering an <span class="apidoc_code">AssertionMarshaller</span>. <span class="apidoc_code">AssertionMarshaller</span> is an interface that an author can implement that will be called by the framework with a DOM element representing an assertion. The author returns an <span class="apidoc_code">Assertion</span> implementation back to the framework. This Assertion implementation will be passed to policy handlers later. Policy authors can also use the following:</p>
<ul>
	<li>To use the <span class="apidoc_code">XmlAssertion</span>, authors can use the existing <span class="apidoc_code">XmlAssertionMarshaller</span>.</li>
	<li>To use JAXB, authors can use the <span class="apidoc_code">JaxbAssertionMarshaller</span>.</li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s02_02_policy_handler_factory_api">Policy Handler Factory API</h3>
<p>The Policy Handler Factory API is composed of a small number of interfaces and classes that can be used to provide construction logic for Policy Handlers based on policy assertions modeled in the Policy API. These can be found in the <span class="apidoc_code">com.soa.policy.wspolicy.handler</span> and <span class="apidoc_code">com.soa.policy.wspolicy.handler.ext</span> packages.</p>
<p><img src="images/pmphpgm_02_03.jpg" alt="Policy Handler Factory API" /></p>
<p>The <span class="apidoc_code">WSPHandlerFactory</span> is the interface all policy handler factories must implement. The difference between this and a <span class="apidoc_code">HandlerFactory</span> in the Message Handler Framework in that it is given the effective policy as a set of normalized policy choices represented with the <span class="apidoc_code">PolicyChoices</span> class. Currently, Policy Manager does not allow policy choices at the root of its effective policy, only within assertions themselves.</p>
<p>With this limitation in mind, the <span class="apidoc_code">SimplePolicyHandlerFactory</span> abstract class is provided for policy authors to extend for their policy handler factories. This class provides subclasses with a single choice as the effective policy, which simplifies processing.</p>
<p><a href="#top">Back to top</a></p>



<h2 id="s03_deployment">Policy Handler Deployment</h2>
<p>The Network Director uses the OSGi (Open Services Gateway initiative) framework for deploying features and extensions.</p>
<p>The Policy Handler Framework dynamically constructs the chain of handlers by discovering policy handler factories published as OSGi services by OSGi bundles.</p>
<p>The Policy Handler Framework registers with the OSGi framework for services that implement the <span class="apidoc_code">WSPHandlerFactory</span> interface. It organizes the <span class="apidoc_code">WSPHandlerFactory</span> services into groups as described in the framework/feature sections, through the use of attributes that the <span class="apidoc_code">WSPHandlerFactory</span> services can use to describe themselves. The following are the attributes the Policy Handler Framework will use to group <span class="apidoc_code">WSPHandlerFactory</span> services.</p>
<dl>
<dt id="attrib_name">name</dt>
<dd>Names the handler factory. Can be used by another handler factory if it needs to state a direct dependency on this handler factory (see <a href="#attrib_before"><strong>before</strong></a> and <a href="#attrib_after"><strong>after</strong></a> attributes).</dd>


<dt id="attrib_scope">scope</dt>
<dd>Indicates which organizational group the handlers from the factory should be placed in. Values:
<ul>
	<li><strong>concrete</strong>&#8212;Deploy a factory instance for a specific binding (see the binding property).</li>
	<li><strong>abstract</strong>&#8212;Deploy a factory instance at the service level so that it creates a handler for messages sent/received over any binding.</li>
</ul></dd>


<dt id="attrib_binding">binding</dt>
<dd>Indicates which binding the factory should be deployed for (if the <a href="#attrib_scope"><strong>scope</strong></a> attribute value is <strong>concrete</strong>).</dd>


<dt id="attrib_role">role</dt>
<dd>Indicates whether the handlers from the factory should be used for receiving message exchanges (virtual services) or initiating message exchanges (downstream services). The values are:
<ul>
	<li><strong>consumer</strong>&#8212;Used for initiating exchanges</li>
	<li><strong>provider</strong>&#8212;Used for receiving exchanges</li>
</ul></dd>

<dt id="attrib_before">before</dt>
<dd>Specifies an ordering requirement or dependency within the group of handler factories it is deployed to. The value is either the name of another handler factory or the wildcard (<strong>*</strong>). If the wildcard (<strong>*</strong>) is specified, the factory must be placed before all other factories in the group.</dd>
<dd>If multiple factories have the same value, the framework orders them in the order the OSGi framework discovers them.</dd>


<dt id="attrib_after">after</dt>
<dd>Specifies an ordering requirement or dependency within the group of handler factories it is deployed to. The value is either the name of another handler factory or the wildcard (<strong>*</strong>). If the wildcard (<strong>*</strong>) is specified, the factory must be placed before all other factories in the group.</dd>
<dd>If multiple factories have the same value, the framework orders them in the order the OSGi framework discovers them.</dd>
</dl>
<p>The following is an example of how policy handler factories can be defined as OSGi services, and the resulting invocation order:</p>
<ul>
	<li><a href="#s03_01_definition">Definition of services</a></li>
	<li><a href="#s03_01_results">Resulting deployment</a></li>
</ul>

<h4 id="s03_01_definition">Definition of services:</h4>
<p><strong>Factory1</strong></p>
<ul>
	<li>Name: Factory1</li>
	<li>Scope: abstract</li>
	<li>Role: provider</li>
</ul>
<p><strong>Factory2</strong></p>
<ul>
	<li>Name: Factory2</li>
	<li>Scope: abstract</li>
	<li>Role: provider</li>
	<li>Before: *</li>
</ul>
<p><strong>Factory3</strong></p>
<ul>
	<li>Name: Factory3</li>
	<li>Scope: concrete</li>
	<li>Binding: soap</li>
	<li>Role: provider</li>
</ul>
<p><strong>Factory4</strong></p>
<ul>
	<li>Name: Factory4</li>
	<li>Scope: concrete</li>
	<li>Binding: soap</li>
	<li>Role: provider</li>
	<li>After: Handler5</li>
</ul>
<p><strong>Factory5</strong></p>
<ul>
	<li>Name: Factory5</li>
	<li>Scope: concrete</li>
	<li>Binding: soap</li>
	<li>Role: provider</li>
</ul>
<h4 id="s03_01_results">Resulting deployment:</h4>
<p><img src="images/pmphpgm_02_04.jpg" alt="Resulting deployment" /></p>
<p>In this example:</p>
<ul>
	<li>Handler1, Handler2, and Handler3 are in the same global/binding group and are deployed first.</li>
	<li>Handler2 is given the first position in the invocation order because it specified a <strong>before</strong> attribute of <strong>*</strong>.</li>
	<li>Handler1 or Handler3 could have been second since there were no ordering constraints on either one, but in this example Handler1 will be second. Handler4 and Handler5 are in the second message-specific group.</li>
	<li>Handler5 will be deployed before Handler4 though because of Handler4's <strong>after</strong> attribute which referred directly to Handler5.</li>
</ul>
<p>For OUT bindings, these same example services would be defined with the same attributes except that the <strong>role</strong> attribute would have the value of <strong>consumer</strong>. The deployment order would be the same.</p>
<p><a href="#top">Back to top</a></p>



<h2 id="s04_development">Developing a Policy Handler</h2>
<p>This section describes the steps necessary to develop and deploy a Policy Handler. The sample artifacts described are available in the /samples directory installed with the product.</p>
<p>In the example, a policy will be written that will dictate that a transport header be present with the same value as the operation name as defined by the service's WSDL document. The policy handler will be written to both enforce and implement the policy.</p>
<p>This section includes:</p>
<ul>
	<li><a href="#s04_01_schema">Policy Assertion Schema</a></li>
	<li><a href="#s04_02_source_code">Source Code</a></li>
	<li><a href="#s04_03_bundle">Bundle</a></li>
	<li><a href="#s04_4_deployment">Deployment</a></li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s04_01_schema">Policy Assertion Schema</h3>
<p>The assertion used in the example is defined by the XML schema shown below.</p>
<pre>01)   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
02)   &lt;xs:schema targetNamespace="http://soa.com/products/policymanager/examples/policy/complex" 
elementFormDefault="qualified" attributeFormDefault="unqualified" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
03)    &lt;xs:element name="Complex"&gt;
04)      &lt;xs:complexType&gt;
05)        &lt;xs:sequence&gt;
06)          &lt;xs:element name="HeaderName" type="xs:string"&gt;&lt;/xs:element&gt;
07)          &lt;xs:element name="Optional" type="xs:boolean"&gt;&lt;/xs:element&gt;
08)        &lt;/xs:sequence&gt;
09)      &lt;/xs:complexType&gt;
10)    &lt;/xs:element&gt;
11)   &lt;/xs:schema&gt;</pre>
<p>The assertion name is <strong>Complex</strong> as defined on line 03. The assertion has two elements:</p>
<ul>
	<li><strong>HeaderName</strong> on line 06 identifies the name of the header that the operation name must be in.</li>
	<li><strong>Optional</strong> on line 07 indicates whether the presence of the header is optional or required.</li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s04_02_source_code">Source Code</h3>
<p>This section includes the following source code examples:</p>
<ul>
	<li><a href="#jaxb_01">Generated JAXB Java class representing the Complex assertion</a></li>
	<li><a href="#jaxb_02">Complex class with optional additional step</a></li>
	<li><a href="#source_code_custom_marshaller">Source code for the custom marshaller</a></li>
	<li><a href="#source_code_provider">Source Code for the Provider</a></li>
	<li><a href="#source_code_consumer">Source code for the Consumer Handler</a></li>
	<li><a href="#source_code_policy_handler_factory">Source code for the Policy Handler Factory</a></li>
</ul>
<h4 id="jaxb_01">Generated JAXB Java class representing the Complex assertion</h4>
<p>In this example, JAXB is used to bind the XML assertion to Java. The generated JAXB java class that represents the Complex assertion is shown below.</p>
<pre>01) @XmlAccessorType(XmlAccessType.FIELD)
02) @XmlType(name = "", propOrder = {
03)  "headerName",
04)  "optional"
05) })
06) @XmlRootElement(name = "Complex")
07) public class Complex {
08)
09)  @XmlElement(name = "HeaderName", required = true)
10)  protected String headerName;
11)  @XmlElement(name = "Optional")
12)  protected boolean optional;
13)
14)  public String getHeaderName() {
15)  return headerName;
16)  }
17)
18)  public void setHeaderName(String value) {
19)  this.headerName = value;
20)  }
21)
22)  public boolean isOptional() {
23)  return optional;
24)  }
25)
26)  public void setOptional(boolean value) {
27)  this.optional = value;
28)  }
29)
30) }</pre>

<h4 id="jaxb_02">Complex class with optional additional step</h4>
<p>When using JAXB, a <span class="apidoc_code">JavaAssertion</span> is generated when unmarshalling the policy. The <span class="apidoc_code">Complex</span> class is contained within the <span class="apidoc_code">JavaAssertion</span>. In this example, an optional step is taken: The <span class="apidoc_code">JavaAssertion</span> class is extended to provide methods that mimic the <span class="apidoc_code">Complex</span> class, so that clients are unaware of the use of JAXB or the necessity to extract the JAXB object from the <span class="apidoc_code">JavaAssertion</span>. This is completely optional.</p>
<pre>01) public class ComplexAssertion extends JavaAssertion {
02)
03)  private static Log log = Log.getLog(ComplexAssertion.class);
04)
05)  private Complex complex = new Complex();
06)
07)  private  Complex getComplex() {
08)  Complex complexPolicy  = null;
09)  try{
10)  if (getObject() instanceof Complex){
11)  complexPolicy = (Complex)getObject();
12)  }
13)  else {
14)  throw new RuntimeException(
15)  "The object " + getObject()+ " is not an Complex");
16)  }
17)  }
18)  catch (Throwable t){
19)  log.error(t);
20)  }
21)  return complexPolicy;
22)  }
23)
24)  private Complex createComplex(){
25)  if (super.getObject() == null){
26)  try{
27)  Complex complexPolicy = new Complex();
28)  complexPolicy.setHeaderName("");
29)  super.setObject(complexPolicy);
30)  }
31)  catch (Throwable t){
32)  log.error(t);
33)  }
34)  }
35)  if(!(super.getObject() instanceof Complex))  {
36)  throw new RuntimeException(
37)  "The object " + getObject()+ " is not an Complex");
38)  }
39)  return (Complex)super.getObject();
40)  }
41)
42)  public String getHeaderName() {
43)  return getComplex().getHeaderName();
44)  }
45)
46)  public boolean  isOptional() {
47)  return getComplex().isOptional();
48)  }
49)
50)  public void setHeaderName(String headerName) {
51)  createComplex().setHeaderName(headerName);
52)  }
53)
54)  public void setOptional(boolean optional) {
55)  createComplex().setOptional(optional);
56)  }
57)
58)  public void setObject(Object object) {
59)  try{
60)  if(object instanceof Complex)
61)  super.setObject(object);
62)  else{
63)  throw new RuntimeException("The object " + object + " is not an Complex");
64)  }
65)  }
66)  catch (Throwable t){
67)  log.error(t);
68)  }
69)  }
70) }</pre>

<h4 id="source_code_custom_marshaller">Source code for the custom marshaller</h4>
<p>If the <span class="apidoc_code">JavaAssertion</span> was used directly by the handler code, we could also just use the <span class="apidoc_code">JavaAssertionMarshaller</span> directly, to marshal the assertion between Java and XML. Since this example is using its own custom assertion class that wraps the <span class="apidoc_code">JavaAssertion</span>, it also requires a custom marshaller, as shown below.</p>
<pre>01) public class ComplexAssertionMarshaller implements AssertionMarshaller {
02)
03)  private static QName[] supportedAssertions =
04)  new QName[] { ComplexPolicyConstants.COMPLEX_POLICY_NAME };
05)
06)  private JaxbAssertionMarshaller jaxbMarshaller;
07)
08)  public void setJaxbMarshaller(JaxbAssertionMarshaller jaxbMarshaller) {
09)  this.jaxbMarshaller = jaxbMarshaller;
10)  }
11)
12)  @Override
13)  public QName[] getSupportedAssertions() {
14)  return supportedAssertions;
15)  }
16)
17)  @Override
18)  public void marshal(Assertion assertion, Element element) throws GException {
19)    if(assertion instanceof ComplexAssertion) {
20)    ComplexAssertion complexAssertion = (ComplexAssertion)assertion;
21)    Complex complexPolicy = (Complex)complexAssertion.getObject();
22)    if (complexPolicy == null) { // in case it wasn't constructed completely
23)      complexPolicy = new Complex();
24)      complexAssertion.setObject(complexPolicy);
25)      complexAssertion.setName(ComplexPolicyConstants.COMPLEX_POLICY_NAME);
26)    }
27)    this.jaxbMarshaller.marshal(assertion, element);
28)      } else {
29)        throw new GException(PolicyErrorCode.UNSUPPORTED_ASSERTION);
30)      }
31)    }
32)
33)    @Override
34)    public Assertion unmarshal(Element element) throws GException {
35)      ComplexAssertion  complexAssertion = new ComplexAssertion();
36)      JavaAssertion javaAssertion =
37)         (JavaAssertion)this.jaxbMarshaller.unmarshal(element);
38)     if(javaAssertion.getObject() instanceof Complex) {
39)          Complex  complexPolicy = (Complex)javaAssertion.getObject();
40)        complexAssertion.setObject(complexPolicy);
41)      }
42)      else {
43)        throw new GException(PolicyErrorCode.UNSUPPORTED_ASSERTION);
44)    }
45)
46)    return  complexAssertion;
47)    }
48)
49)    @Override
50)    public Assertion unmarshal(Element element, Policy subPolicy)
51)        throws GException {
52)      throw new GException(PolicyErrorCode.SUB_POLICY_NOT_SUPPORTED);
53)    }
54)  }</pre>
<p>In this example:</p>
<ul>
	<li>A <span class="apidoc_code">JaxbAssertionMarshaller</span> is embedded in this custom marshaller, on line 6.</li>
	<li>The marshaller returns to the framework the assertions it supports on line 14. This tells the framework what XML elements to ask the marshaller to process.</li>
	<li>On lines 18&#8211;31 the marshaller extracts the assertion information and creates the Complex JAXB object that it can then marshal to an XML element using the JaxbAssertionMarshaller.</li>
	<li>On lines 34&#8211;47 the marshaller uses the JaxbAssertionMarshaller to marshal the XML element to a Complex JAXB object. It then wraps the output in a ComplexAssertion object.</li>
	<li>When the framework detects that the assertion has a nested policy, the unmarshal method starting on line 50 is called.</li>
	<li>In this case, on line 52, the marshaller throws an exception, since this assertion does not support nested policies. It should not be called by the framework unless the policy was somehow created incorrectly.</li>
</ul>

<h4 id="source_code_provider">Source Code for the Provider</h4>
<p>There are two policy handlers in this example, one acting as a consumer of message exchanges and the other a provider. The source code for the provider is shown below.</p>
<pre>01) public class ComplexPolicyProviderHandler implements MessageHandler {
02)
03)  // QName of missing header fault code
04)  private static final QName MISSING_HEADER_CODE =
05)  new QName(ComplexPolicyConstants.COMPLEX_POLICY_NS, "MissingHeader");
06)  // Message for missing header
07)  private static final String MISSING_HEADER_MSG = "Required header was missing";
08)  // QName of incorrect header content fault code
09)  private static final QName INVALID_HEADER_CODE =
10)  new QName(ComplexPolicyConstants.COMPLEX_POLICY_NS, "InvalidValue");
11)  // Message for incorrect header content
12)  private static final String INVALID_HEADER_MSG =
13)  "Header value does not match operation";
14)
15)  private String headerName;
16)  private boolean isOptional = true;
17)
18)  private static Log log = Log.getLog(ComplexPolicyProviderHandler.class);
19)
20)  public void setHeaderName(String headerName) {
21)  this.headerName = headerName;
22)  }
23)
24)  public void setOptional(boolean isOptional) {
25)  this.isOptional = isOptional;
26)  }
27)
28)  public void close(MessageContext context) {
29)  // no cleanup necessary
30)  }
31)
32)  /* Checks for the existence of the header and verifies the value matches the
33)  * current operation
34)  */
35)  public boolean handleMessage(MessageContext context)
36)  throws MessageFaultException {
37)  try {
38)  Header header = null;
39)  // get the current transport headers
40)  Headers headers = (Headers)context.getMessage().getProperty(
41)  MessageProperties.TRANSPORT_HEADERS);
42)  if (headers != null) {
43)  header = headers.getHeader(this.headerName);
44)  String operationName = context.getExchange().getOperationName();
45)  // if the header doesn't match the current operation flag as an error
46)  if (header != null &amp;&amp; !header.getValue().equals(operationName)) {
47)  MessageFaultException mfe =
48)  new MessageFaultException(INVALID_HEADER_CODE, INVALID_HEADER_MSG);
49)  // set error so an alert is generated - must match alert code in PM
50)  mfe.setError(ComplexPolicyErrorCode.INVALID_HEADER_ERROR,
51)  new Object[] {operationName, this.headerName, header.getValue()});
52)  throw mfe;
53)  }
54)  }
55)  // if the header is mandatory but not present flag as an error
56)  if (!isOptional &amp;&amp; header == null) {
57)  MessageFaultException mfe =
58)  new MessageFaultException(MISSING_HEADER_CODE, MISSING_HEADER_MSG);
59)  // set error so an alert is generated - must match alert code in PM database
60)  mfe.setError(ComplexPolicyErrorCode.MISSING_HEADER_ERROR,
61)  new Object[] {this.headerName});
62)  throw mfe;
63)  }
64)  return true; // continue handler processing
65)  } catch (Exception e) {
66)  log.error(e);
67)  throw new MessageFaultException(
68)  ComplexPolicyConstants.COMPLEX_FAULT_CODE, e.getLocalizedMessage());
69)  }
70)  }
71) }</pre>
<p>In this example:</p>
<ul>
	<li>The header name and optional flag from the policy assertion are private data members on lines 15 and 16. The handler does not read the assertion itself. That is the job of the factory (see <a href="#s04_02_source_code">Source Code</a> section).</li>
	<li>Starting on line 35, the <span class="apidoc_code">handleMessage()</span> method is called by the framework to enforce the policy when receiving a request (IN) message. It is not called when processing a response (OUT) message because a handler is not created for the response message by the factory (see below).</li>
	<li>On line 44, the handler retrieves the header with the name in the policy.</li>
	<li>On line 46, the handler compares the header value to the operation name. If they do not match, a <span class="apidoc_code">MessageFaultException</span> is generated and thrown on lines 47&#8211;52. The exception tells the framework that policy enforcement has failed and instructs it to return a fault to the client with the code and message added to the exception.</li>
	<li>On line 56, the handler checks in case the header is not present and its presence is not optional. If this is the case, it generates a different <span class="apidoc_code">MessageFaultException</span> with a different code and message on lines 57&#8211;62.</li>
	<li>If none of the checks fail, the handler indicates that the message has passed policy enforcement by returning <strong>true</strong> on line 64.</li>
	<li>In this example, the <span class="apidoc_code">close()</span> method on lines 28&#8211;30 perform no function. Hsowever, if the handler were to have allocated resources that should be cleaned up only after the entire handler chain had finished its processing, those steps would be included at this point.</li>
</ul>

<h4 id="source_code_consumer">Source code for the Consumer Handler</h4>
<p>The source code for the consumer handler is shown below. The purpose of this code is to create a header with the name in the policy with the value of the current operation, so that the message passes enforcement at the downstream service.</p>
<pre>01) public class ComplexPolicyConsumerHandler implements MessageHandler {
02)
03)  private static Log log = Log.getLog(ComplexPolicyConsumerHandler.class);
04)  private String headerName;
05)
06)  public void setHeaderName(String headerName) {
07)  this.headerName = headerName;
08)  }
09)
10)  public void close(MessageContext context) {
11)  // no cleanup necessary
12)  }
13)
14)  /* Inserts the operation name as an outbound transport header. */
15)  public boolean handleMessage(MessageContext context)
16)  throws MessageFaultException {
17)  try {
18)  // get the current outbound transport headers
19)  Headers headers = (Headers)context.getMessage().getProperty(
20)  MessageProperties.TRANSPORT_HEADERS);
21)  // may not be any yet, if that's the case create a new property for it
22)  if (headers == null) {
23)  headers = new BasicHeaders();
24)  }
25)  if (headers.containsHeader(this.headerName)) {
26)  /* if it's there it may be left over from the inbound side (see
27)  * preserve transport headers) and we must remove it
28)  */
29)  headers.removeHeader(this.headerName);
30)  // add the new header, get the operation name from the exchange
31)  headers.addHeader(
32)  this.headerName, context.getExchange().getOperationName());
33)  }
34)  return true; // continue handler processing
35)  } catch (Exception e) {
36)  log.error(e);
37)  throw new MessageFaultException(
38)  ComplexPolicyConstants.COMPLEX_FAULT_CODE, e.getLocalizedMessage());
39)  }
40)  }
41)  }</pre>

<h4 id="source_code_policy_handler_factory">Source code for the Policy Handler Factory</h4>
<p>The source code of the policy handler factory is below. Only one factory is needed to create both the provider and consumer policy handlers.</p>
<pre>01) public class ComplexPolicyHandlerFactory extends SimplePolicyHandlerFactory {
02)
03)  // capability stating support for the policy
04)  private static PolicyHandlerFactoryCapability gCapability;
05)  static {
06)  gCapability = new PolicyHandlerFactoryCapability();
07)  gCapability.addSupportedAssertionNamespace(
08)  ComplexPolicyConstants.COMPLEX_POLICY_NS);
09)  }
10)
11)  protected MessageHandler create(Policy policy, HandlerContext context,
12)  HandlerRole role) throws GException {
13)  MessageHandler handler = null;
14)  Assertion complexAssert = getAssertion(policy);
15)  if (complexAssert != null) {
16)  // our marshaller returns a JavaAssertion holding a Complex object
17)  Complex complex = (Complex)((ComplexAssertion)complexAssert).getObject();
18)  // only if being called on provider side for an IN message we create a
19)  // provider handler
20)  if (role == HandlerRole.PROVIDER &amp;&amp;
21)  ((WSDLHandlerContext)context).getParameterType() == ParameterType.IN) {
22)  ComplexPolicyProviderHandler providerHandler =
23)  new ComplexPolicyProviderHandler();
24)  providerHandler.setHeaderName(complex.getHeaderName());
25)  providerHandler.setOptional(complex.isOptional());
26)  handler = providerHandler;
27)  // only if being called on consumer side for an IN message we create a
28)  // consumer handler
29)  } else if (role == HandlerRole.CONSUMER &amp;&amp;
30)  ((WSDLHandlerContext)context).getParameterType() == ParameterType.IN) {
31)  ComplexPolicyConsumerHandler consumerHandler =
32)  new ComplexPolicyConsumerHandler();
33)  consumerHandler.setHeaderName(complex.getHeaderName());
34)  handler = consumerHandler;
35)  }
36)  }
37)  return handler;
38)  }
39)
40)  /* Return the policy we support */
41)  public PolicyHandlerFactoryCapability getCapability() {
42)  return gCapability;
43)  }
44)
45)  /* Find the policy assertion we support, if present */
46)  private Assertion getAssertion(PolicyOperator po) {
47)  Assertion complexAssert = null;
48)
49)  // first check if present in policy operator's immediate child assertions
50)  for (Assertion assertion : po.getAssertions()) {
51)  if (assertion.getName().equals(ComplexPolicyConstants.COMPLEX_POLICY_NAME)) {
52)  complexAssert = assertion;
53)  break;
54)  }
55)  }
56)
57)  if (complexAssert == null) {
58)  for (PolicyOperator subPo : po.getPolicyOperators()) {
59)  if ((complexAssert = getAssertion(subPo)) != null) {
60)  break;
61)  }
62)  }
63)  }
64)  return complexAssert;
65)  }
66) }</pre>
<p>The handler factory extends <span class="apidoc_code">SimplePolicyHandlerFactory</span> since there is no chance of getting top-level policy choices.</p>
<p>In this example:</p>
<ul>
	<li>On line 14, the assertion is extracted from the policy using the <span class="apidoc_code">getAssertion()</span> method on lines 46&#8211;65. That method recursively searches for an assertion with the Complex assertion's name.</li>
	<li>On line 20, the check is made to see if a provider handler should be constructed and returned. If the role of the handler to be returned is <span class="apidoc_code">HandlerRole.PROVIDER</span> and the message that the handler will process is the IN message, a provider handler should be returned.</li>
	<li>One line 29, the check is made to see if a consumer handler should be constructed and returned. If the role of the handler to be returned is <span class="apidoc_code">HandlerRole.CONSUMER</span> and the message the handler will process is the IN message then a consumer handler should be returned.</li>
</ul>
<p>A common point of confusion is that, although the message being processed is sent out of the container, it is still the input message of the downstream service's operation, so it is the IN message, not the OUT message.</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s04_03_bundle">Bundle</h3>
<p>The classes described in the previous section must be packaged in an OSGi bundle so that they can be deployed to the Akana container. The ComplexAssertionMarshaller and ComplexPolicyHandlerFactory must be published as an OSGi service so that the Policy Handler Framework can load them. In this example, Blueprint is used to construct and publish the OSGi services using Spring. Spring and Blueprint are not requirements, but are used here for simplicity.</p>

<h4 id="bundle_assertionmarshaller">Assertion Marshaller</h4>
<p>The assertion marshaller is published using the following Spring snippet.</p>
<pre>01) &lt;bean id="complex.assertion.marshaller"
class="com.soa.examples.policy.complex.assertion.marshaler.ComplexAssertionMarshaller"
&gt;
02)  &lt;property name="jaxbMarshaller" ref="complex.jaxb.marshaller"/&gt;
03) &lt;/bean&gt;
04)
05) &lt;bean id="complex.jaxb.marshaller"
class="com.soa.policy.wspolicy.JaxbAssertionMarshaller"  init-method="init"&gt;
06)  &lt;property name="assertionQNames"&gt;
07)  &lt;list&gt;
08)  &lt;ref bean="complex.assertion.name"/&gt;
09)  &lt;/list&gt;
10)  &lt;/property&gt;
11)  &lt;property name="jaxbPaths"&gt;
12)  &lt;list&gt;
13)  &lt;value&gt;com.soa.examples.policy.complex.assertion.model&lt;/value&gt;
14)  &lt;/list&gt;
15)  &lt;/property&gt;
16) &lt;/bean&gt;
17)
18) &lt;bean id="complex.assertion.name" class="javax.xml.namespace.QName"&gt;
19)  &lt;constructor-arg value="http://soa.com/products/policymanager/examples/policy/complex" /&gt;
20)  &lt;constructor-arg value="Complex"/&gt;
21) &lt;/bean&gt;
22)
23) &lt;osgi:service ref="complex.assertion.marshaller"
interface="com.soa.policy.wspolicy.AssertionMarshaller"&gt;
24)  &lt;osgi:service-properties&gt;
25)  &lt;entry key="name" value="com.soa.examples.policy.complex.marshaller"/&gt;
26)  &lt;/osgi:service-properties&gt;
27) &lt;/osgi:service&gt;
</pre>
<p>In this example:</p>
<ul>
	<li>Lines 01&#8211;21 construct the <span class="apidoc_code">ComplexAssertionMarshaller</span> and all its dependencies. The <span class="apidoc_code">JaxbAssertionMarshaller</span> that is used within the <span class="apidoc_code">ComplexAssertionMarshaller</span> is constructed on lines 05&#8211;16.</li>
	<li>The <span class="apidoc_code">ComplexAssertionMarshaller</span> is published as an OSGi service on lines 23&#8211;27. It must be published using the <span class="apidoc_code">AssertionMarshaller</span> interface. It is given a <strong>name</strong> property on line 25 as a good practice when publishing OSGi services. The name should be unique among all services published.</li>
</ul>

<h4 id="bundle_complexpolicyhandlerfactory">ComplexPolicyHandlerFactory</h4>
<p>The <span class="apidoc_code">ComplexPolicyHandlerFactory</span> is published using the following Spring snippet. Because the policy handlers are validating and creating transport level headers the factory will be published with a <strong>concrete</strong> scope instead of <strong>abstract</strong>. Although <strong>abstract</strong> is easier for defining policies that are independent of binding, not all bindings will have transport headers and there will definitely not be transport headers when a virtual service invokes another virtual service in the same container.</p>
<pre>01) &lt;bean id="complex.wsphandler.factory" class="com.soa.examples.policy.complex.handler.ComplexPolicyHandlerFactory"/&gt;
02)
03) &lt;  osgi:service  ref="complex.wsphandler.factory"
interface="com.soa.policy.wspolicy.handler.WSPHandlerFactory"&gt;
04)  &lt;osgi:service-properties&gt;
05)  &lt;entry key="name" value="com.soa.examples.complex.in.http.wsp.factory"/&gt;
06)  &lt;entry key="scope" value="concrete"/&gt;
07)  &lt;entry key="binding" value="http"/&gt;
08)  &lt;entry key="role" value="provider"/&gt;
09)  &lt;/osgi:service-properties&gt;
10) &lt;/osgi:service&gt;
11)
12) &lt;osgi:service  ref="complex.wsphandler.factory" interface="com.soa.policy.wspolicy.handler.WSPHandlerFactory"&gt;
13)  &lt;osgi:service-properties&gt;
14)  &lt;entry key="name" value="com.soa.examples.complex.in.soap.wsp.factory"/&gt;
15)  &lt;entry key="scope" value="concrete"/&gt;
16)  &lt;entry key="binding" value="soap"/&gt;
17)  &lt;entry key="role" value="provider"/&gt;
18)  &lt;/osgi:service-properties&gt;
19) &lt;/osgi:service&gt;
20)
21) &lt;osgi:service  ref="complex.wsphandler.factory" interface="com.soa.policy.wspolicy.handler.WSPHandlerFactory"&gt;
22)  &lt;osgi:service-properties&gt;
23)  &lt;entry key="name" value="com.soa.examples.complex.out.http.wsp.factory"/&gt;
24)  &lt;entry key="scope" value="concrete"/&gt;
25)  &lt;entry key="binding" value="http"/&gt;
26)  &lt;entry key="role" value="consumer"/&gt;
27)  &lt;/osgi:service-properties&gt;
28) &lt;/osgi:service&gt;
29)
30) &lt;osgi:service  ref="complex.wsphandler.factory" interface="com.soa.policy.wspolicy.handler.WSPHandlerFactory"&gt;
31)  &lt;osgi:service-properties&gt;
32)  &lt;entry key="name" value="com.soa.examples.complex.out.soap.wsp.factory"/&gt;
33)  &lt;entry key="scope" value="concrete"/&gt;
34)  &lt;entry key="binding" value="soap"/&gt;
35)  &lt;entry key="role" value="consumer"/&gt;
36)  &lt;/osgi:service-properties&gt;
37) &lt;/osgi:service&gt;</pre>
<p>The creation of the <span class="apidoc_code">ComplexPolicyHandler</span> factory is simple and is done on line 01. Then, that same factory instance is published to both the HTTP (REST) and SOAP bindings. Because the factory constructs handlers acting in both the <strong>consumer</strong> and <strong>provider</strong> roles, it must be published multiple times with those roles. In all, the single factory instance is published as four OSGi services:</p>
<ul>
	<li>On lines 03&#8211;10, the factory is published as a provider-side HTTP factory.</li>
	<li>On lines 12&#8211;19 the factory is published as a provider-side SOAP factory.</li>
	<li>On lines 21&#8211;28 the factory is published as a consumer-side HTTP handler.</li>
	<li>On lines 30&#8211;37 the factory is published as a consumer-side SOAP handler.</li>
</ul>

<h4 id="bundle_osgibundlemanifest">OSGi Bundle Manifest</h4>
<p>An OSGi bundle must have a Manifest to define its dependencies. The following is the Manifest for this example.</p>
<pre>01)  Manifest-Version: 1.0
02)  Bundle-ManifestVersion: 2
03)  Bundle-Name: SOA Software Complex Policy Handler Example
04)  Bundle-SymbolicName: com.soa.examples.policy.handler.complex
05)  Bundle-Version: 7.0.0
06)  Bundle-Vendor: SOA Software
07)  Import-Package: com.digev.fw.exception;version="7.0.0",
08)    com.digev.fw.log;version="7.0.0",
09)    com.soa.message;version="7.0.0",
10)    com.soa.message.handler;version="7.0.0",
11)    com.soa.message.handler.wsdl;version="7.0.0",
12)    com.soa.message.header;version="7.0.0",
13)    com.soa.message.header.impl;version="7.0.0",
14)    com.soa.policy;version="7.0.0",
15)    com.soa.policy.template;version="7.0.0",
16)    com.soa.policy.wspolicy;version="7.0.0",
17)    com.soa.policy.wspolicy.handler;version="7.0.0",
18)    com.soa.policy.wspolicy.handler.ext;version="7.2.0",
19)    javax.xml.bind,
20)    javax.xml.bind.annotation,
21)    javax.xml.namespace,
22)    org.w3c.dom
23)  Export-Package: com.soa.examples.policy.complex,
24)    com.soa.examples.policy.complex.assertion,
25)    com.soa.examples.policy.complex.assertion.model,
26)    com.soa.examples.policy.complex.template</pre>
<p>In the above:</p>
<ul>
	<li>Lines 01&#8211;06 hold general information about the Bundle.</li>
	<li>Lines 07&#8211;22 hold the package dependencies for the Bundle. All packages not defined within the bundle that are imported by code in the Bundle must be listed here. The only exceptions to this are packages that are in the global classpath of the Akana Container, such as the Java JRE and Spring packages.</li>
	<li>Lines 23&#8211;26 list the packages that are exported, or published, to other bundles loaded in the system. This is required so that the Policy Handler Framework can load the assertion classes as they are constructed using a JAXB context from another bundle and could possibly be used by a user interface bundle for displaying the policy in the Policy Manager Management Console.</li>
</ul>
<p><a href="#top">Back to top</a></p>


<h3 id="s04_4_deployment">Deployment</h3>
<p>An Akana container will have a folder on the file system with a name that matches the key of the container seen in the Policy Manager Management Console. Under that folder is a sub-folder named <strong>deploy</strong>. </p>
<p>Bundles that provide extensions to the container, such as additional message handlers, are placed in the <strong>deploy</strong> folder.</p>
<p>When the container is restarted, the services published within any Bundles in the <strong>deploy</strong> folder are imported into the container, and all published handler factories and assertion marshallers are picked up by the Policy Handler Framework.</p>
<p><a href="#top">Back to top</a></p>



<h2 id="s05_references">References</h2>
<dl>
<dt>[WS-Policy]</dt>
<dd>D. Box, et al, <strong>Web Services Policy Framework (WS-Policy)</strong>, April 2006. (See <a href="http://www.w3.org/Submission/2006/SUBM-WS-Policy-20060425/" target="_blank">http://www.w3.org/Submission/2006/SUBM-WS-Policy-20060425/</a>)</dd>

<dt>[WS-PolicyAttachment]</dt>
<dd>D. Box, et al, <strong>Web Services Policy Attachment (WS-PolicyAttachment)</strong>, April 2006. (See <a href="http://www.w3.org/Submission/2006/SUBM-WS-PolicyAttachment-20060425/" target="_blank">http://www.w3.org/Submission/2006/SUBM-WS-PolicyAttachment-20060425/</a>)</dd>
</dl>
<p><a href="#top">Back to top</a></p>



<hr class="divide_hr" />



<h2 id="related_topics">Related Topics</h2>
<div class="relatedlinks">
<ul>
	<li><a href="../policies/about_policies_view.htm">About Policies</a></li>
	<li><a href="../policies/policy_management.htm">Managing Policies</a></li>
	<li><a href="../policies/policies_operational_about.htm">About Operational Policies</a></li>
</ul>
<ul>
	<li><a href="pm_message_handler_programming_guide.htm">Message Handler Programming Guide</a></li>	
	<li><a href="../../cm/learnmore/basics_glossary.htm">Glossary of Terms for the Community Manager developer portal</a></li>
</ul>
</div>

