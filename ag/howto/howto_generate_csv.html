<!DOCTYPE html>
<html>
<head>
<title>howto_generate_csv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<hr />
<p>layout: page
title: How to Generate CSV Responses
description: A how to guide for providing a specific CSV response for a message
product: ag
category: learn
sub-nav-class: Mediation
weight: 05
type: page</p>
<h2>nav-title: Generate CSV Response</h2>
<h2>How to Generate CSV Responses</h2>
<p>We had a customer scenario where they wanted the product to take a complex XML response and generate a simple CSV format with just a few of the response message elements.  We could have done this using XSL-T, but I didn’t like this approach because it did give me the flexibility I wanted (plus my XSL is terrible).  So I did this using scripts, with a process context variable of type String named acceptHeader.  One in front of the invoke that captures the accept header and stores in the the processContext variable, and if it’s CSV forces the addition of an options query param to ensure we get all the info we need.</p>
<p>This is a very over-simple model that doesn't attempt to read through any returned array of &quot;product&quot; objects (it just assumes it's a single entry array and reads the values from the first one).  It really should write a header, and then iterate through the products array to generate a real response, but this gives the basic idea of how to make this work.</p>
<p>```javascript
// Grab the Accept header and store it in a variable
var msg = processContext.getVariable(&quot;message&quot;);
var headers = msg.getTransportHeaders();
var acceptHeader = headers.get(&quot;Accept&quot;).getValue();
processContext.setVariable(&quot;acceptHeader&quot;, acceptHeader);
auditLog.debug(&quot;Accept: &quot; + acceptHeader);</p>
<p>// If it's CSV then add the options=PRODUCTS query param
if (acceptHeader == &quot;text/csv&quot;) {
    auditLog.debug(&quot;Adding query string&quot;);
    msg.setProperty(&quot;com.soa.message.TRANSPORT_QUERY&quot;, &quot;options=PRODUCTS&quot;);
}
```</p>
<p>And another one after the invoke that checks to see what the original accept header was, and if it’s CSV it gets the bits of the message it needs and makes a CSV string:</p>
<p>```javascript
// If the Accept header was CSV, then mediate the content
var acceptHeader = processContext.getVariable(&quot;acceptHeader&quot;);
auditLog.debug(&quot;Accept: &quot; + acceptHeader);</p>
<p>if (acceptHeader == &quot;text/csv&quot;) {</p>
<pre><code>var msg = processContext.getVariable(&quot;message&quot;);

// force the message to JSON
var normmsg = msg.normalize();

// This will be going away, but for now grab a JSONLib serializer
var serializer = new net.sf.json.xml.XMLSerializer();

// And convert the normalized message to JSON
var jsonContent = serializer.read(normmsg.getContentAsString());

// Parse the JSON doc
jsonVar = JSON.parse(jsonContent,null);

// Get the bits we need
var name = jsonVar[&quot;name&quot;];
var url = jsonVar[&quot;url&quot;];
var products = jsonVar[&quot;products&quot;];
var product = products[&quot;product&quot;];
var code = product[&quot;code&quot;];

var newContent = code + &quot;,&quot; + url + &quot;,&quot; + name;

msg.setStringContent(newContent);

msg.setContentType(&quot;text/csv&quot;);
</code></pre>

<p>}
```</p>
<p>This works with Accept set to application/xml, application/json, or text/csv.  It will return whichever you ask for.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
