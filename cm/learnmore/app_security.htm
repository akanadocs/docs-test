---
layout: page
title: App Security Options and Setup | App Development | Community Manager Help
description: Learn about how to set up and manage app security.
product: cm
category: learn
subcategory: App Security
weight: 23
type: page
nav-title: App Security
---
<h2 id="top">App Security Options and Setup</h2>
<p>It's important to set up authentication for the messages your app sends to an API you&rsquo;re using. Authentication protects the sender, the receiver, and the message itself. It&rsquo;s important that the security is strong enough that a third party couldn&rsquo;t pose as the sender, pose as the receiver, and/or view or change the message content.</p>
<p>Authentication and security are particularly important when money and sensitive personally identifiable information are involved.</p>
<p>Once your app is registered, it's important to set up authentication so that the app can use the API to process messages securely.</p>
<p>This document provides information about the various security options available to you and the steps that you'll need to take to set up the option you choose.</p>
<h5>What do you want to read about?</h5>
<ul>
  <li><a href="#appsecurityoverview">App Security Overview</a></li>
  <li><a href="#authenticating_hmac_ss">HMAC Signature with Shared Secret</a></li>
  <li><a href="#authenticating_hash_ss">Hash/Digest with Shared Secret</a></li>
  <li><a href="#authenticating_rsa_pki">RSA Signature with PKI</a></li>
  <li><a href="#ref_notes_and_procedures">Reference Notes and Procedures</a></li>
  <li><a href="#errors_all">Error Codes and Descriptions</a></li>
</ul>
<p class="apidoc_note"><strong>Note</strong>: This topic provides information about setting up your app to authenticate with an API hosted on the platform. For implementation information and examples for a specific API you're using, refer to the documentation for that API.</p>
<hr />


<a name="appsecurityoverview"></a><h3>App Security Overview</h3>
<p>This section provides general information about the security mechanisms available on the platform to provide authentication. It includes:</p>
<ul>
  <li><a href="#security_mechanisms_available">Security Mechanisms Available</a></li>
  <li><a href="#including_token">Including Token in Request Message</a></li>
  <li><a href="#token_structure">Token Structure</a></li>
  <li><a href="#authentication_realm">Authentication Realm</a></li>
</ul>


<a name="security_mechanisms_available"></a><h4>Security Mechanisms Available</h4>
<p>In the platform, as part of setting up your app, you&rsquo;ll need to choose the security mechanism you&rsquo;ll use for authentication of your messages. You can choose between these options:</p>
<ul>
  <li><a href="#authenticating_hmac_ss">HMAC Signature with Shared Secret</a></li>
  <li><a href="#authenticating_hash_ss">Hash/Digest with Shared Secret</a></li>
  <li><a href="#authenticating_rsa_pki">RSA Signature with PKI</a></li>
</ul>
<p>The first two use a Shared Secret value generated by the platform for your app, but use different algorithms for constructing the signature; the last mechanism uses RSA security with public/private key.</p>
<p>Below are some points about the various security mechanisms to help you determine which approach is best for your app.</p>
<ul>
  <li>All approaches, Shared Secret and RSA, Signature with PKI, are very secure. All use a secret key combined with hashing and encoding, and are sent via HTTPS.</li>
  <li>The Shared Secret approaches are easier to implement since you don't have to generate public and private keys.</li>
  <li>The HMAC Signature with Shared Secret and PKI approaches are a little more secure than Hash/Digest with Shared Secret, although all three approaches are very secure.</li>
  <li> The PKI approach is more complex to implement than Shared Secret approaches since it requires external key generation.</li>
  <li>HMAC Signature with Shared Secret is compatible with the OAuth 1.0 standard. However, this standard is now deprecated (see <a href="http://oauth.net/core/1.0/" target="_blank">OAuth Core 1.0 specification</a>)(external site).</li>
  <li>HMAC Signature with Shared Secret offers a library support and examples based on the programming language. </li>
  <li>With all options, F5 to ND hop in DMZ would not cause any problems as the signature is still valid and encrypted. </li>
</ul>
<p class="apidoc_note"><strong>Note</strong>: The platform also supports OAuth 1.0a and OAuth 2.0.</p>



<a name="including_token"></a><h4>Including Token in Request Message</h4>
<p>There are three ways you can include the token in the request message:</p>
<ul>
  <li>In the authorization headers</li>
  <li>In a cookie</li>
  <li>As query/POST parameters</li>
</ul>



<a name="token_structure"></a><h4>Token Structure</h4>
<p>In order for the platform to recognize your app, you must construct a token and send it with the request message.</p>
<p>The values that make up the token, and the way it's constructed, vary according to the security mechanism you're using. The table below lists all token values and indicates the security mechanisms for which each is valid. The specific values and their sequence depend on the specific security mechanism you choose; the procedures for setting up each security mechanism include exact instructions for constructing the token for that mechanism.</p>
<p class="apidoc_note"><strong>Note</strong>: Each value includes a prefix, the value of which is determined by the Site Admin. In the table below, and everywhere in this document, we use a fictitious company name, <strong>acmecorp</strong>, for the prefix; for example, <strong>acmecorp_app_id</strong>. In your installation it will be some other value; for example, it might be the Tenant ID. If you're not sure what value to use, consult your site administrator.</p>
<table width="98%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table description">
<thead>
  <tr>
    <th width="25%">Name</th>
    <th width="20%">Used By</th>
    <th width="55%">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><a name="acmecorp_app_id"></a>acmecorp_app_id</td>
    <td>All</td>
    <td>The AppID assigned to the app in the platform.</td>
  </tr>
  <tr>
    <td><a name="acmecorp_nonce"></a>acmecorp_nonce</td>
    <td>All</td>
    <td><p>A random string, uniquely generated for each request. The nonce allows the API providers to verify that a request has never been made before and helps prevent replay attacks when requests are made over a non-secure channel.</p>
      <p>For more information, see <a href="#generatingnonce">Generating a Nonce Value</a>.</p></td>
  </tr>
  <tr>
    <td><a name="acmecorp_secret_digest"></a>acmecorp_secret_digest</td>
    <td>Hash/Digest with Shared Secret</td>
    <td>A value produced by concatenating the nonce, the timestamp, and the Shared Secret, hashing the combined value using SHA-1, and then Base-64 encoding the result. You can also URL-encode the result, but this isn't required.</td>
  </tr>
  <tr>
    <td><a name="acmecorp_signature_method"></a>acmecorp_signature_method</td>
    <td>All</td>
    <td><p>A value indicating the signature method. Valid values:</p>
      <ul class="apidoctable_ul">
        <li>For HMAC Signature with Shared Secret: <strong>HMAC-SHA1</strong> or <strong>HMAC-SHA256</strong>.</li>
        <li>For Hash/Digest with Shared Secret: <strong>Digest</strong>.</li>
        <li>For RSA Signature with PKI: <strong>SHA1withRSA</strong>,<strong>SHA236withRSA</strong>, or <strong>NONE</strong>. The <strong>NONE</strong> signature method is used for APIs that don't require security. In this case, only the acmecorp_app_id is required in the HTTP Authorization headers.</li>
      </ul></td>
  </tr>
  <tr>
    <td><a name="acmecorp_signature"></a>acmecorp_signature</td>
    <td> HMAC Signature with Shared Secret, RSA Signature with PKI</td>
    <td>The signature value. For information on how the signature value is calculated, see <a href="#composing_signature_hmac_ss">Composing the Signature: HMAC Signature with Shared Secret</a> or <a href="#composing_signature_rsa_pki">Composing the Signature: RSA Signature with PKI</a>.</td>
  </tr>
  <tr>
    <td><a name="acmecorp_timestamp"></a>acmecorp_timestamp</td>
    <td>All</td>
    <td><p>The timestamp of the request, expressed as the number of milliseconds since January 1, 1970 00:00:00 GMT. The timestamp must be a positive integer and must be greater than or equal to the timestamp used in previous requests.</p>
      <p>For more information, see <a href="#generatingtimestamp">Generating the Timestamp</a>.</p></td>
  </tr>
  <tr>
  <td><a name="acmecorp_version"></a>acmecorp_version</td>
    <td>All</td>
    <td>The platform version. Optional. If present, the value must be 1.0.</td>
  </tr>
</tbody>
</table>


<a name="authentication_realm"></a><h4>Authentication Realm</h4>
<p>Every authentication mechanism offered by the platform includes a specific authentication parameter, <strong>realm</strong>, that identifies the fact that the message comes from the realm for your app.</p>
<p>In the platform, you can specify the value to be used for the realm parameter, but there are restrictions. There are two choices:</p>
<ul>
  <li>The platform automatically defaults to the first part of the incoming request hostname.</li>
  <li>You can change it, but the value you choose must be a valid part of the incoming request hostname.</li>
</ul>
<p>Let's say, for example, the hostname for your API requests is <strong>acmecorp.payments.com</strong>. The platform defaults to <strong>acmecorp</strong>. You can change it to payments, but you cannot choose <strong>acmecorporation</strong>. You must choose a valid part of the hostname.</p>
<p>The value for the realm is configured for the platform in the <a href="basics_glossary.htm#gl_api_gateway">API Gateway</a> by the Administrator.</p>
<p>When constructing the signature, do not include the realm in the signature base string (see later sections for specific instructions).</p>
<p>For more information about use of the realm parameter in authentication, refer to the <a href="http://tools.ietf.org/html/rfc2617#section-1.2" target="_blank">Access Authentication Framework</a> section of the HTTP Authentication standard for Basic and Digest Access Authentication.</p>
<p><a href="#top">Back to top</a></p>
<hr />



<a name="authenticating_hmac_ss"></a><h3>HMAC Signature with Shared Secret</h3>
<p>When you use the HMAC Signature with Shared Secret option, you do not need to send the Shared Secret. You just use it to create the signature.</p>
<p>This approach essentially follows the mechanism laid out in the OAuth 1.0 specification (deprecated; see <a href="http://oauth.net/core/1.0/" target="_blank">OAuth Core 1.0 specification</a>).</p>
<p>This section includes:</p>
<ul>
  <li><a href="#headerexample_hmac_ss">Authenticating with HMAC signature: Process Flow</a></li>
  <li><a href="#headerexample_hmac_ss">HMAC Signature with Shared Secret: Header Example</a></li>
  <li><a href="#signing_hmac_ss">HMAC Signature with Shared Secret: Signing Requests with the Shared Secret</a></li>
  <li><a href="#composing_signature_hmac_ss">Composing the Signature: HMAC Signature with Shared Secret</a></li>
  <li><a href="#constructingsbs_hmac_ss">Constructing the Signature Base String (HMAC Signature with Shared Secret)</a></li>
  <li><a href="#example_sbs_hmac_ss">Signature Base String: Examples (HMAC Signature with Shared Secret)</a></li>
  <li><a href="#computing_signature_hmac_ss">Computing the Signature Value (HMAC Signature with Shared Secret)</a></li>
  <li><a href="#oauth10_hmac_ss">Compatibility with OAuth 1.0 (a deprecated standard)</a></li>
  <li><a href="#example_java_hmac_ss">Java Example: Creating an HMAC Signature with Shared Secret</a></li>
</ul>


<a name="processflow_hmac_ss"></a><h4>Authenticating with HMAC Signature with Shared Secret: Process Flow</h4>
<p> The process flow diagram below shows an overview of API request authentication with HMAC Signature with Shared Secret.</p>
<p class="apidoc_image_p"><img src="images/processflow_apirequestauth_hmac_app.jpg" alt="Process flow: HMAC signature with shared secret security mechanism" width="590" height="565" /></p>



<a name="headerexample_hmac_ss"></a><h4>HMAC Signature with Shared Secret: Header Example</h4>
<p>If you choose the HMAC Signature with Shared Secret authentication mechanism, your HTTP Authorization header must include the values shown below. For definitions of each value, refer to <a href="#token_structure">Token Structure</a>.</p>
<ul>
  <li><a href="#acmecorp_app_id">acmecorp_app_id</a></li>
  <li><a href="#acmecorp_nonce">acmecorp_nonce</a></li>
  <li><a href="#acmecorp_signature_method">acmecorp_signature_method</a></li>
  <li><a href="#acmecorp_signature">acmecorp_signature</a></li>
  <li><a href="#acmecorp_timestamp">acmecorp_timestamp</a></li>
  <li><a href="#acmecorp_version">acmecorp_version</a></li>
</ul>
<p>Below is an example of an Authorization header with app authentication parameters, when you use the HMAC Signature with Shared Secret approach. <!--RS__ Query is sequence important with HMAC. The sequence of the parameters isn't significant, but all parameters must be present with valid values.--></p>
<p class="apidoc_note"><strong>Note</strong>: The value for the realm is determined by the www-Authenticate header. Make sure the value you set in the Authorization header is correct for your installation. For more information about the <strong>realm</strong> value, see <a href="#authentication_realm">Authentication Realm</a>.</p>
<pre>Authorization: acmecorp realm="http://acmecorp",
  acmecorp_app_id="myplatform-AS0iTmhoGaE6Y9sWhUkvcL6T",
  acmecorp_nonce="4572616e48616d6d65724c61686176",
  acmecorp_signature_method="HMAC-SHA1",
  acmecorp_signature="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
  acmecorp_timestamp="137131200",
  acmecorp_version="1.0"
</pre>

<a name="signing_hmac_ss"></a><h4>HMAC Signature with Shared Secret: Signing Requests with the Shared Secret</h4>
<p>The Shared Secret is a binary hashed value, generated within the secure environment of the platform and known only to you and to the platform. For more information, see <a href="app_create_app_security.htm#what_is_a_shared_secret">What is a Shared Secret?</a></p>
<p>With the HMAC Signature with Shared Secret security mechanism, you do the following:</p>
<ol>
  <li>Compose the Signature. See <a href="#composing_signature_hmac_ss">Composing the Signature: HMAC Signature with Shared Secret</a>.</li>
  <li>Hash the result using the SHA-1 secure hashing algorithm.</li>
  <li>Encode the hashed value using the Base64 encoding scheme.</li>
  <li>Optional: You can also URL-encode the result, but this isn't required.</li>
  <li>Assign the result as the value for the acmecorp_secret_digest parameter.</li>
  <li>Send it in the HTTP Authorization message header.</li>
</ol>



<a name="composing_signature_hmac_ss"></a><h4>Composing the Signature: HMAC Signature with Shared Secret</h4>
<p>The basic process for computing the digital signature is to:</p>
<ol>
  <li><a href="#constructingsbs_hmac_ss">Construct a Signature Base String</a> based on:
<ul>
      <li>Request URL</li>
      <li>Request parameters</li>
      <li>POST body parameters (if the POST body is of the URL-encoded type; otherwise the POST body is ignored)</li>
    </ul>
    </li>
  
  <li>Apply the hash and signature algorithm against the Signature Based String. </li>
</ol>
<p class="apidoc_note"><strong>Note</strong>: The acmecorp_signature parameter <em>must</em> be excluded from the Signature Base String.</p>


<a name="constructingsbs_hmac_ss"></a>
<h4>Constructing the Signature Base String (HMAC Signature with Shared Secret)</h4>
<p>The process of constructing the Signature Base String consists of three steps:</p>
<ol>
  <li>Normalize request parameters: see <a href="#normalize_hmac_ss">To normalize request parameters</a>.</li>
  <li>Construct request URL: see <a href="#construct_url_hmac_ss">To construct the request URL</a>.</li>
  <li>Concatenate request elements: see <a href="#concatenate_hmac_ss">To concatenate request elements</a>.</li>
</ol>

<p>For instructions, refer to <a href="#constructingsbs_shared">Constructing the Signature Base String</a>.</p>



<a name="example_sbs_hmac_ss"></a><h4>Signature Base String: Examples (HMAC Signature with Shared Secret)</h4>
<p>Below are two examples of the Signature Base String for HMAC/Shared Secret authentication.</p>
<p>For a POST request:</p>
<pre>
POST&amp;https://api.com/Payments/Funds&amp;acmecorp_app_id=myplatform-AS0iTmhoGaE6Y9sWhUkvcL6T&amp;acmecorp_nonce=1326409129918&amp;
acmecorp_signature_method=HMAC-SHA1&amp;acmecorp_timestamp=1326409129918&amp;acmecorp_version=1.0</pre>
<p>For a GET request:</p>
<pre>
GET&amp;https://api.com/Payments/FundDetails&amp;a=1&amp;acmecorp_app_id=myplatform-AS0iTmhoGaE6Y9sWhUkvcL6T&amp;acmecorp_nonce=1326409129918&amp;
acmecorp_signature_method=HMAC-SHA1&amp;acmecorp_timestamp=1326409129918&amp;acmecorp_version=1.0&amp;id=123</pre>


<a name="computing_signature_hmac_ss"></a><h4>Computing the Signature Value (HMAC Signature with Shared Secret)</h4>
<p>Once you have the signature base string, the next step is to compute the signature with the AppSecret using the HMAC_SHA1 algorithm.</p>
<p>There are three steps:</p>
<ol>
  <li>Base64-encode the signature value.</li>
  <li>URL-encode the result into a string.</li>
  <li>Set the string as the value for the acmecorp_signature parameter.</li>
</ol>
<p>For example, let's say the value of the signature is:</p>
<pre>g682XYDko3%2BqIn0xmFfLTbtGgO%2Fa5vrOOgeJ4iOu0Myx99Pq84triSJLdxVq8KlMcKrJjbd96pEbU3tA2</pre>
<p>In this example, the Authorization header would look something like this:</p>
<pre>Authorization: acmecorp realm="http://acmecorp",
acmecorp_app_id="myplatform-AS0iTmhoGaE6Y9sWhUkvcL6T",
acmecorp_nonce="1326409129918",
acmecorp_signature_method="HMAC-SHA1",
acmecorp_signature="g682XYDko3%2BqIn0xmFfLTbtGgO%2Fa5vrOOgeJ4iOu0Myx99Pq84triSJLdxVq8KlMcKrJjbd96pEbU3tA2",
acmecorp_timestamp="1326409129918",
acmecorp_version="1.0"</pre>


<a name="oauth10_hmac_ss"></a><h4>Compatibility with OAuth 1.0 (a deprecated standard)</h4>
<p>HMAC Signature with Shared Secret is compatible with the OAuth 1.0 standard. However, this standard is now deprecated (see <a href="http://oauth.net/core/1.0/" target="_blank">OAuth Core 1.0 specification</a>).</p>


<a name="example_java_hmac_ss"></a><h4>Java Example: Creating an HMAC Signature with Shared Secret</h4>
<p>Below is an example of how to create an HMAC signature with Shared Secret in Java.</p>
<pre>
  // get an hmac_sha1 key from the raw key bytes
SecretKeySpec signingKey = new SecretKeySpec(secKey.getBytes(), "HmacSHA1");

  // get an hmac_sha1 Mac instance and initialize with the signing key
Mac mac = Mac.getInstance("HmacSHA1");
mac.init(signingKey);

  // compute the hmac on input data bytes
byte[] rawHmac = mac.doFinal(signatureBaseString.getBytes());

  // base64-encode the hmac
String resultSignature = org.apache.commons.codec.binary.Base64.encodeBase64String(rawHmac);
</pre>

<p><a href="#top">Back to top</a></p>
<hr />


<a name="authenticating_hash_ss"></a><h3>Hash/Digest with Shared Secret</h3>
<p>The Shared Secret is a binary hashed value, generated within the secure environment of the platform and known only to you and to the platform. For more information, see <a href="app_create_app_security.htm#what_is_a_shared_secret">What is a Shared Secret?</a></p>
<p>With the Hash/Digest with Shared Secret security mechanism, you do the following:</p>
<ol>
  <li>Combine the Shared Secret with two other values.</li>
  <li>Hash the result using the SHA-1 secure hashing algorithm.</li>
  <li>Encode the hashed value using the Base64 encoding scheme.</li>
  <li>Optional: You can also URL-encode the result, but this isn't required.</li>
  <li>Assign the result as the value for the acmecorp_secret_digest parameter.</li>
  <li>Include this parameter in the HTTP Authorization message header.</li>
</ol>
<p>The API verifies each incoming request using the Shared Secret.</p>
<p>More information about the shared secret approach is given in these sections:</p>
<ul>
  <li><a href="#processflow_ss">Authenticating with the Hash/Digest with Shared Secret: Process Flow</a></li>
  <li><a href="#sampleheader">Sample Header With Authorization Parameters (Hash/Digest with Shared Secret)</a></li>
  <li><a href="#hashing_sha1">Hashing With the SHA-1 Secure Hash Algorithm</a></li>
  <li><a href="#encodingbasestring">Encoding the base string into bytes</a></li>
  <li><a href="#example_java_sha1">Java Example: Creating a Shared Secret Hash</a></li>
</ul>


<h4><a name="processflow_ss"></a>Authenticating with the Hash/Digest with Shared Secret: Process Flow</h4>
<p> The process flow diagram below shows an overview of API request authentication with the shared secret security mechanism.</p>
<p class="apidoc_image_p"><img src="images/processflow_apirequestauth_ss_app.jpg" alt="Process flow: shared secret security mechanism" width="592" height="535" /></p>


<a name="sampleheader"></a><h4>Sample Header With Authorization Parameters (Hash/Digest with Shared Secret)</h4>
<p>If you choose the Hash/Digest with Shared Secret authentication mechanism, your HTTP Authorization header must include the values shown below. For definitions of each value, refer to <a href="#token_structure">Token Structure</a>.</p>
<ul>
  <li><a href="#acmecorp_app_id">acmecorp_app_id</a></li>
  <li><a href="#acmecorp_nonce">acmecorp_nonce</a></li>
  <li><a href="#acmecorp_secret_digest">acmecorp_secret_digest</a></li>
  <li><a href="#acmecorp_signature_method">acmecorp_signature_method</a></li>
  <li><a href="#acmecorp_timestamp">acmecorp_timestamp</a></li>
  <li><a href="#acmecorp_version">acmecorp_version</a></li>
</ul>





<p>Below is an example of an Authorization header with app authentication parameters, when you use the Hash/Digest with Shared Secret approach. The sequence of the parameters isn't significant, but all parameters must be present with valid values.</p>
<p class="apidoc_note"><strong>Note</strong>: The value for the realm is determined by the www-Authenticate header. Make sure the value you set in the Authorization header is correct for your installation. For more information about the <strong>realm</strong> value, see <a href="#authentication_realm">Authentication Realm</a>.</p>
<pre>Authorization: acmecorp realm="http://acmecorp",
  acmecorp_app_id="development-AS0iTmhoGaE6Y9sWhUkvcL6T",
  acmecorp_nonce="1326409129918",
  acmecorp_secret_digest="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
  acmecorp_digest_method="SHA1",
  acmecorp_timestamp="1326755565940",
  acmecorp_version="1.0"
</pre>


<a name="hashing_sha1"></a><h4>Hashing With the SHA-1 Secure Hash Algorithm</h4>
<p>SHA-1 is a cryptographic hash function, broadly used and trusted.</p>
<p>When you hash a value with SHA-1, the hash function returns a 160-bit string. This is the message digest. The value is hashed and sent with the message; at the receipt point, the value is hashed again, and the two hash values are compared. When the two hash values match, it is a secure, reliable indication that the message hasn't changed; the message at the receipt point is an accurate duplication of the message at the send point.</p>
<p>If you're using the Shared Secret security mechanism, you concatenate the nonce, the timestamp, and the Shared Secret, and then you hash that combined value using SHA-1. You then encode the result, and send it in the message header as the value for the acmecorp_secret_digest parameter.</p>
<p>The formula for computing the hash is:</p>
<pre>acmecorp_secret_digest = Base64 ( SHA-1 ( nonce + created + AppSecret ) )</pre>
<p>Below is an example of a hashed base string:</p>
<pre>
1326409129918+1326755565940+2d9d42b42a4e2abc1fa5489d5081e03b95818ffd</pre>


<h4><a name="encodingbasestring"></a>Encoding the base string into bytes</h4>
<p>When you concatenate the nonce, timestamp, and app secret into a base string to be hashed, you'll need to make sure the concatenated value is a byte value before hashing. The hashing algorithm requires the input parameter to be in bytes. Depending on your app, you might need to use encoding to get a byte value. If so, use UTF-8 encoding.</p>
<p>Below is an example using Java.</p>
<pre>
MessageDigest md = MessageDigest.getInstance("SHA1"); 
md.update(baseString.getBytes("UTF-8")); or
md.update(baseString.getBytes()); 
String digest = encodeAsBase64String(md.digest());</pre>
<p class="apidoc_note"><strong>Note</strong>: The example above is part of a larger Java sample for a specific API. For more information, refer to the implementation examples for the API you're using.</p>


<a name="example_java_sha1"></a><h4>Java Example: Creating a Shared Secret Hash</h4>
<p>Below is an example of how to create the acmecorp_secret_digest value in Java.</p>
<pre>  //Use the shared secret of app on file
String sharedSecret = "1008877afabf32efb31f9c974dbeaa688bed0769";

  // Generate the nonce value
Import java.security.SecureRandom:
Random rand = SecureRandom.getInstance ("SHA1PRNG");
long nonce = rand.nextLong();

  // Get the timestamp in milliseconds
long timestamp = System.currentTimeMillis();
 
  // Concatenate the nonce, timestamp, and Shared Secret
String baseString = String.valueOf(nonce) + String.valueOf(timestamp) + sharedSecret;

  // Hash the concatenated value into a message digest using SHA-1
MessageDigest md = MessageDigest.getInstance("SHA1");
md.update(baseString.getBytes());
  // Encode the message digest using Base-64 encoding
String digest = encodeAsBase64String(md.digest());</pre>
<p><a href="#top">Back to top</a></p>
<hr />



<a name="authenticating_rsa_pki"></a><h3>RSA Signature with PKI</h3>
<p>When you register your app in the platform, you can set up app security in the <em>Security Credentials</em> section of your <em>App Details</em> page.</p>
<p>If you want to use Public Key Infrastructure (PKI) for secure message signing, click the button to choose Public Key Integration. You'll need to get a public/private key pair and upload the public key to the platform, as explained later in this document. In the custom app code you will sign the API requests using the private key. The API verifies each incoming request using the public key.</p>
<p>More information about authenticating with PKI is given in these sections:</p>
<ul>
  <li><a href="#processflow_pki">Authenticating with PKI: Process Flow</a></li>
  <li><a href="#generatingkeypair">Generating a Public/Private Keypair</a></li>
  <li><a href="#sample_header_pki">Sample Headers (PKI Approach)</a></li>
  <li><a href="#signing_pki">Signing Requests with Private Key</a></li>
  <li><a href="#composing_signature_rsa_pki">Composing the Signature: RSA Signature with PKI</a></li>
  <li><a href="#constructingsbs_rsa_pki">Constructing the Signature Base String (PKI Approach)</a></li>
  <li><a href="#example_sbs_rsa_pki">Signature Base String: Example (PKI Approach)</a></li>
  <li><a href="#signingandencoding_rsa_pki">Signing the Signature Base String and Encoding the Signature (PKI Approach)</a></li>
</ul>


<a name="processflow_pki"></a><h4>Authenticating with PKI: Process Flow</h4>
<p> The process flow diagram below shows an overview of API request authentication with PKI.</p>
<p class="apidoc_image_p"><img src="images/processflow_apirequestauth_pki_app.jpg" alt="Process flow: PKI security mechanism" width="585" height="538" /></p>


<a name="generatingkeypair"></a><h4>Generating a Public/Private Keypair</h4>
<p>The first step is to generate the public/private keypair for your app.</p>
<p>For a detailed example, refer to <a href="#generating_keypair_openssl">Generating PKI Key Pair with Certificate Using OpenSSL</a> later in this document.</p>


<a name="sample_header_pki"></a><h4>Sample headers (PKI approach)</h4>
<p>This section gives some sample headers, including:</p>
<ul>
  <li><a href="#sample_pki_authparms">Sample header with authorization parameters (PKI approach)</a></li>
  <li><a href="#sample_pki_noauthparms">Sample header without authorization parameters (PKI approach)</a></li>
</ul>


<a name="sample_pki_authparms"></a><h5>Sample header with authorization parameters</h5>
<p>Below is an example of an Authorization header with app authentication parameters. Make sure you list the parameters in the sequence shown below.</p>
<p class="apidoc_note"><strong>Note</strong>: The value for the realm is determined by the www-Authenticate header. Make sure the value you set in the Authorization header is correct for your installation. For more information about the <strong>realm</strong> value, see <a href="#authentication_realm">Authentication Realm</a>.</p>
<pre>Authorization: realm="http://acmecorp",
  acmecorp_app_id="acmecorp-7FSXeNRkVRJ8XtAurgaea65R",
  acmecorp_nonce="1323732744354",
  acmecorp_signature_method="SHA1withRSA",
  acmecorp_signature="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
  acmecorp_timestamp="1323732744354",
  acmecorp_version="1.0"</pre>


<a name="sample_pki_noauthparms"></a><h5>Sample header without authorization parameters</h5>
<p> Below is an example of an Authorization header for an API that doesn't require authentication.</p>
<pre>
Authorization: realm=&quot;http://acmecorp&quot;,
acmecorp_app_id=&quot;http://www.acmecorp.com/app/101&quot;,
acmecorp_signature_method=&quot;NONE&quot;</pre>
<p class="apidoc_note"><strong>Note</strong>: In case the client, such as an Ajax client in the browser or an Android app, cannot set the HTTP Authorization header, you can set the required authorization header parameters in the HTTP query string.</p>


<a name="signing_pki"></a><h4>Signing Requests with Private Key</h4>
<p>The signature process for signing the request with private key follows a similar approach to the <a href="http://tools.ietf.org/html/rfc5849" target="_blank">OAuth 1.0 standard</a>. The platform uses an HTTP Extension header to support its app authentication scheme. The name of this extension header is configurable; the examples in this document use a fictitious value, acmecorp. The extension header uses the standard HTTP Authorization header and WWW-Authenticate response header to pass app-related authentication parameters. The HTTP query string can also be used to pass authentication data for cases where the app cannot directly manipulate HTTP headers.</p>


<h4>WWW-Authenticate header</h4>
<p> API providers can indicate their support for the extension by returning the HTTP WWW-Authenticate header in response to app requests for protected resources. Below is an example:</p>
<pre>
WWW-Authenticate: acmecorp realm=&quot;http://acmecorp&quot;</pre>


<h4>Authorization header</h4>
<p>Apps should send their credentials in the HTTP Authorization header. If you choose the Public Key Integration approach for your app security, your HTTP Authorization header must include the values shown below.</p>
<p class="apidoc_note"><strong>Important</strong>: The sequence of the header attributes is critical and must exactly match the order below.</p>
<ul>
  <li><a href="#acmecorp_app_id">acmecorp_app_id</a></li>
  <li><a href="#acmecorp_nonce">acmecorp_nonce</a></li>
  <li><a href="#acmecorp_signature_method">acmecorp_signature_method</a></li>
  <li><a href="#acmecorp_signature">acmecorp_signature</a></li>
  <li><a href="#acmecorp_timestamp">acmecorp_timestamp</a></li>
  <li><a href="#acmecorp_version">acmecorp_version</a></li>
</ul>


<a name="composing_signature_rsa_pki"></a><h4>Composing the Signature: RSA Signature with PKI</h4>
<p>When using the RSA Signature with PKI authentication approach, there are several steps to composing the signature:</p>
<ul>
  <li><a href="#constructingsbs_rsa_pki">Constructing the Signature Base String (PKI Approach)</a></li>
  <li><a href="#signingandencoding_rsa_pki">Signing the Signature Base String and Encoding the Signature (PKI Approach)</a></li>
</ul>


<a name="constructingsbs_rsa_pki"></a><h4>Constructing the Signature Base String (PKI Approach)</h4>
<p>The first step in composing the digital signature is to create the content. Once that's done, the data is signed using the signature algorithm.</p>
<p class="apidoc_note"><strong>Note</strong>: The acmecorp_signature parameter <em>must</em> be excluded from the Signature Base String.</p>
<p>The process of constructing the Signature Base String consists of three steps:</p>
<ol>
  <li>Normalize request parameters: see <a href="#normalize_hmac_ss">To normalize request parameters</a>.</li>
  <li>Construct request URL: see <a href="#construct_url_hmac_ss">To construct the request URL</a>.</li>
  <li>Concatenate request elements: see <a href="#concatenate_hmac_ss">To concatenate request elements</a>.</li>
</ol>

<p>For instructions, refer to <a href="#constructingsbs_shared">Constructing the Signature Base String</a>.</p>



<a name="example_sbs_rsa_pki"></a><h4>Signature Base String: Example (PKI Approach)</h4>
<p>Below is an example of the Signature Base String when using the RSA with PKI approach.</p>
<pre>
POST&amp;https://api.sandbox.yoursandbox.com/APIName/Payment/v1/MethodName
&amp;acmecorp_app_id=acmecorp-7FSXeNRkVRJ8XtAurgaea65R
&amp;acmecorp_nonce=1323732744354&amp;acmecorp_signature_method=SHA1withRSA
&amp;acmecorp_timestamp=1323732744354&amp;acmecorp_version=1.0</pre>


<a name="signingandencoding_rsa_pki"></a><h4>Signing the Signature Base String and Encoding the Signature (PKI Approach)</h4>
<p>Once the Signature Base String is constructed, the next step is signing:</p>
<ol>
  <li>Use the SHA-1 algorithm to generate the hash of the Signature Base String.</li>
  <li>Sign the hashed value using the private key of the app.</li>
  <li>Base64-encode the signature value. For instructions, see <a href="#encoding_base64">Encoding with the Base64 Encoding Scheme</a>.
  <span class="apidoc_note"><strong>Note:</strong> Base64 encoding should <em>not</em> include the CRLF (carriage return/line feed) every 72 characters which is part of strict Base64 encoding. Instead, the whole Base64 encoded string should be without line breaks.</span>
</li>
  <li>Optionally, URL-encode the result into a string.</li>
  <li>Set the string as the value for the acmecorp_signature parameter.</li>
</ol>
<p><a href="#top">Back to top</a></p>
<hr />



<a name="ref_notes_and_procedures"></a><h3>Reference Notes and Procedures</h3>
<p>This section includes overview information about the authentication process and specific details and procedures about aspects of the process of composing the signature. It includes:</p>
<ul>
  <li><a href="#generatingtimestamp">Generating the Timestamp</a></li>
  <li><a href="#generatingnonce">Generating a Nonce Value</a></li>
  <li><a href="#constructingsbs_shared">Constructing the Signature Base String</a></li>
  <li><a href="#generating_keypair_openssl">Generating PKI Key Pair with Certificate Using OpenSSL</a></li>
  <li><a href="#java_keystorejdk">Java Developers: Generating a Keystore and CSR with the JDK Keytool</a></li>
  <li><a href="#encoding_base64">Encoding with the Base64 Encoding Scheme</a></li>
  <li><a href="#compromise">What If the Private Key or Shared Secret Is Compromised?</a></li>
<!--  <li><a href="#differences">Differences between PKI-Based (Asymmetric) and Symmetric Key-Based Solutions</a></li>
-->
</ul>



<a name="generatingtimestamp"></a><h4>Generating the Timestamp</h4>
<p>The timestamp of the request is sent in the message header, for both Shared Secret and PKI security mechanisms. In the Shared Secret mechanism it is also used in creating the Secret Digest.</p>
<p> The timestamp must be in Unix epoch time, expressed as the number of milliseconds since January 1, 1970 00:00:00 GMT. The timestamp must be a positive integer and must be greater than or equal to the timestamp used in previous requests. In most implementations, the timestamp is taken from the host server. It's important that the timestamp in the message is accurate; if the timestamp is off, the message might be rejected.</p>
<p>For more information on Unix epoch time, and examples of implementation of the timestamp in different programming languages, see <a href="http://www.epochconverter.com" target="_blank">http://www.epochconverter.com</a> (scroll down).</p>
<p>A Java example of generating the timestamp is shown below.</p>
<pre>  // Get the timestamp in milliseconds
long timestamp = System.currentTimeMillis();</pre>


<a name="generatingnonce"></a><h4>Generating a Nonce Value</h4>
<p>A nonce is a random string that is uniquely generated for each request. The nonce allows the API providers to verify that a request has never been made before. A nonce is sent in the message header for both Shared Secret and PKI security mechanisms. In the Shared Secret mechanism, the same nonce value sent in the message header is also used in creating the Secret Digest.</p>
<p>The way you create the nonce will depend on your development environment. Most programming languages include a method for creating a nonce. Below is an example of generating a nonce value in Java:</p>
<pre>
  // Generate the nonce value
Import java.security.SecureRandom:
Random rand = SecureRandom.getInstance ("SHA1PRNG");
long nonce = rand.nextLong();</pre>



<a name="constructingsbs_shared"></a><h4>Constructing the Signature Base String</h4>
<p>Constructing a Signature Base String is part of the app security implementation for two approaches:</p>
<ul>
  <li><a href="#authenticating_hmac_ss">HMAC Signature with Shared Secret</a></li>
  <li><a href="#authenticating_rsa_pki">RSA Signature with PKI</a></li>
</ul>
<p>This process includes the steps listed below:</p>
<ol>
  <li>Normalize request parameters: see <a href="#normalize_hmac_ss">To normalize request parameters</a> below.</li>
  <li>Construct request URL: see <a href="#construct_url_hmac_ss">To construct the request URL</a> below.</li>
  <li>Concatenate request elements: see <a href="#concatenate_hmac_ss">To concatenate request elements</a> below.</li>
</ol>


<a name="normalize_hmac_ss"></a><h5>To normalize request parameters:</h5>
<p>Collect the request parameters, sort them, and concatenate them into a normalized string.</p>
<p>Parameters to include:</p>
<ul>
  <li>All parameters in the acmecorp HTTP Authorization header <strong>except</strong> the realm parameter which must <strong>not</strong> be included.</li>
  <li> Parameters in the HTTP POST request body (with a content-type of application/x-www-form-urlencoded).</li>
  <li>HTTP GET parameters added to the URLs in the query part.</li>
</ul>
<p><span class="apidoc_note"><strong>Note</strong>: The acmecorp_signature parameter MUST be excluded.</span></p>
<p>Normalize the parameters into a single string following the steps below:</p>
<ol>
  <li>Sort by parameter name, using lexicographical byte value ordering. If two or more parameters share the same name, sort by value. For example:
<pre>a=1, c=hi%20there, f=25, f=50, f=a, z=p, z=t</pre>
</li>
  <li>When parameters are sorted, concatenate them into a single string. For each parameter, separate the name from the corresponding value by an equals (=) character (ASCII code 61), even if the value is empty. Each name-value pair is separated by an ampersand (&amp;) character (ASCII code 38). For example:
<pre>a=1&amp;c=hi%20there&amp;f=25&amp;f=50&amp;f=a&amp;z=p&amp;z=t</pre>
</li>
</ol>


<a name="construct_url_hmac_ss"></a><h5>To construct the request URL:</h5>
<p>The Signature Base String includes the absolute URL for the request, tying the signature to a specific endpoint. The URL used in the Signature Base String:</p>
<ul>
  <li>Must <strong>include</strong> the scheme, authority, and path.</li>
  <li>Must <strong>exclude</strong> the query and fragment.</li>
</ul>
<p>If the absolute request URL is not available to the API Provider (it is always available to the Application), it can be constructed by combining these three things:</p>
<ul>
  <li>The scheme being used</li>
  <li>The HTTP Host header</li>
  <li>The relative HTTP request URL</li>
</ul>
<p> URL scheme and authority must be lowercase and must include the port number.</p>
<p><span class="apidoc_note"><strong>Note</strong>: HTTP default port 80 and HTTPS default port 443 must be excluded</span>.</p>
<p>For example, this request:</p>
<pre>http://example.com:80/resource?id=123</pre>
<p>Would be included in the Signature Base String as:</p>
<pre>http://example.com/resource</pre>

<a name="concatenate_hmac_ss"></a><h5>To concatenate request elements:</h5>
<p>The following items must be concatenated in order into a single Signature Base string. Each item is encoded and separated by an ampersand (&amp;) character (ASCII code 38), even if empty.</p>
<ul>
  <li>The HTTP request method used to send the request. Value must be uppercase, for example: POST, GET, PUT.</li>
  <li>The request URL.</li>
  <li>The normalized request parameters string. Note that the acmecorp_signature parameter, scheme and realm are excluded. </li>
</ul>
<p>Once you've created the Signature Base String, the next step is to compute the signature. Depending on the approach you're using, refer to the applicable next step:</p>
<ul>
  <li><a href="#computing_signature_hmac_ss">Computing the Signature Value (HMAC Signature with Shared Secret)</a></li>
  <li><a href="#signingandencoding_rsa_pki">Signing the Signature Base String and Encoding the Signature (PKI Approach)</a></li>
</ul>



<a name="generating_keypair_openssl"></a><h4>Generating PKI Key Pair with Certificate Using OpenSSL</h4>
<p>You can use the OpenSSL open source product to produce a public/private key pair. For more information on OpenSSL, refer to <a href="http://www.openssl.org" target="_blank">www.openssl.org</a>.</p>
<p>If you are developing the application using the Microsoft Windows OS you can get an adaptation of OpenSSL for the Windows platform from the following location: <a href="http://code.google.com/p/openssl-for-windows/downloads/list" target="_blank">http://code.google.com/p/openssl-for-windows/downloads/list</a> (external site).</p>
<h4><a name="issuecert"></a>To create a public/private key pair with OpenSSL</h4>
<ol>
  <li>From the URL given above, download the applicable <strong>openssl</strong> archive file for your operating system.</li>
  <li>Unzip the contents to a folder; for example, <strong>C:\openssl</strong>. </li>
  <li>Launch the command-line utility <strong>cmd.exe</strong>.</li>
  <li>Change location to the folder referenced in step 2; for example, <strong>cd c:\openssl</strong>.</li>
<li>To get a certificate, do one of the following:
<ul>
<li>Submit the certificate request (csr.csr) generated in the previous step to a certificate authority. The certificate authority will issue you an X.509 certificate. See <a href="#issuecert_ca">To get a certificate issued by a certificate authority</a>.</li>
<li>Generate a self-signed certificate along with a public/private key pair. See <a href="#issuecert_selfsign">To generate a self-signed certificate</a>.</li>
</ul>
</li>
<li>Upload the certificate file, the result of either of the procedures above, to the Community Manager platform.</li>
</ol>
<p>The keypair and certificate generation process includes the files shown below.</p>
<table width="98%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table description">
<thead>
  <tr>
    <th width="18%">File name</th>
    <th width="14%">Key type</th>
    <th width="68%">Comments</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>privatekey.key</td>
    <td>private key</td>
    <td><p>Make sure you save a copy of the private key in a safe place. If you lose this key you will need to generate a new key pair.</p>
    <p>You will sign your request using the private key. For more information, see <a href="#composing_signature_rsa_pki">Composing the Signature: RSA Signature with PKI</a>.</p></td>
  </tr>
  <tr>
    <td>csr.csr</td>
    <td>certificate signing request</td>
    <td>Submit this to a Certificate Authority. When you get a certificate in response (see <strong>mycert.cer</strong> below), upload it to the Community Manager platform.</td>
  </tr>
  <tr>
    <td>mycert.cer</td>
    <td>X.509 cert (public key)</td>
    <td>Upload this file to the Community Manager platform. The API uses this file for signature verification on your app's API calls.</td>
  </tr>
</tbody>
</table>


<a name="issuecert_ca"></a><h4>To get a certificate issued by a certificate authority</h4>
<ol>
  <li>Follow steps 1-4 of <a href="#issuecert">To create a public/private key pair with OpenSSL</a>.</li>
  <li>At the command prompt, cut and paste or type the following:
<pre>C:\openssl>bin\openssl req -config openssl.cnf -out csr.csr -newkey rsa:2048 -keyout privatekey.key</pre>
</li>
  <li>Enter data for the prompts that appear.
<p class="apidoc_note"><strong>Note</strong>: Anything with an empty bracket set [] is not required.</p>
<p>Below is an example of what you might see in the command-line window.</p>
<p class="apidoc_image_p"><img src="images/generating_csr2.png" alt="Generating the CSR file" /></p>
<p>This process creates your public/private key pair and a certificate signing request (<strong>csr.csr</strong> file) in the <strong>c:\openssl</strong> folder.</p>
</li>
<li>Submit the <strong>csr.csr</strong> file to a certificate authority. The certificate authority will issue you an X.509 certificate.</li>
<li>Upload the certificate file to the Community Manager platform.</li>
</ol>

<h4><a name="issuecert_selfsign"></a>To generate a self-signed certificate</h4>
<ol>
  <li>Follow steps 1-4 of <a href="#issuecert">To create a public/private key pair with OpenSSL</a>.</li>
  <li>At the command prompt, cut and paste or type the following:
    <pre>C:\openssl>bin\openssl req -config openssl.cnf -out mycert.cer -x509 -newkey rsa:2048 -keyout privatekey.key</pre>
  </li>
  <li>Enter data for the prompts that appear. This process generates a self-signed X.509 certificate (<strong>mycert.cer</strong>).
<p>Below is an example of what you might see in the command-line window.</p>
<p class="apidoc_image_p"><img src="images/generating_csr_ssl_02.jpg" alt="Generating a self-signed certificate" /></p>
<p class="apidoc_note"><strong>Note</strong>: Anything with an empty bracket set [] is not required.</p>
 </li>
  <li>Upload the <strong>mycert.cer</strong> file to the Community Manager platform.</li>
</ol>



<a name="java_keystorejdk"></a><h4>Java Developers: Generating a Keystore and CSR with the JDK Keytool</h4>
<p>If you are a Java developer and have worked with cryptography in Java, you might be familiar with the concept of a <strong><em>keystore</em></strong>. A keystore is a file used to store and deploy certificates and private keys in a single package. You can create a keystore using OpenSSL as explained above. However, as a Java developer, it is probably far more convenient to use <strong><em>keytool</em></strong>, a key and certificate management utility that's distributed as part of the Java Development Kit (JDK).</p>
<p>You can use keytool to create both the keystore and the CSR associated with the private key in the keystore. Once you've created your CSR, you upload it to the platform just like any other CSR. Your Java code reads your private key, used for signing the base string used in API request headers, from the keystore file you create.</p>
<p>Since the keytool utility is part of the JDK, you don't have to download anything to create your Java keystore. Just follow the steps below.</p>
<p class="apidoc_note"><strong>Note</strong>: The procedure below assumes that your JDK <strong>bin</strong> directory is in your Windows system path.</p>
<h4>To create a Java keystore using the keytool utility</h4>

<ol>
  <li>Open a command prompt.</li>
  <li>Create the keystore file by typing the following:
  <p><strong>keytool -genkey -alias &lt;keystorealias&gt; -keyalg RSA -keystore &lt;keystore_filename&gt;.p12 -storetype PKCS12 -keypass &lt;password&gt; -keysize 2048</strong></p></li>
  <li>Create the CSR associated with the keystore created in step 2 by typing the following:
  <p><strong>keytool -certreq -alias &lt;keystorealias&gt; -keystore &lt;keystore_filename&gt;.p12 -file &lt;csr_filename&gt;.csr -storetype PKCS12</strong></p></li>
</ol>
<p>The illustration below shows the steps to create a keystore called <span class="apidoc_code">keystore.p12</span> with an alias of <strong>mykeystore</strong> and the password <strong>changeme</strong>.</p>
<p class="apidoc_image_p"><img src="images/java_keytool_createkeystore.png" width="1040" alt="Creating a keystore with the Java keytool utility" /></p>
<p>The illustration below shows how to create a CSR called <strong>csr.csr</strong> from <strong>keystore.p12</strong>.</p>
<p class="apidoc_image_p"><img src="images/java_keytool_createcsr.png" width="811" height="106" alt="Creating a CSR with the Java keytool utility" /></p>
<p class="apidoc_note"><strong>Note</strong>: For implementation examples, check the authentication documentation for the specific API you're using.</p>
<p class="apidoc_note"><strong>IMPORTANT :</strong> Upload the file <strong>CSR.csr</strong> to the portal.</p>



<a name="encoding_base64"></a><h4>Encoding with the Base64 Encoding Scheme</h4>
<p>The Base64 encoding scheme converts binary data into an ASCII string. Encoding turns it into ASCII string format. It's common practice to encode data to make sure it remains intact without modification during transport by HTTP or HTTPS.</p>
<p>As part of setting up your app security, you'll need to encode the values shown below.</p>
<p>If you're using the Shared Secret method with hash/digest,  you must encode the binary hash value that you created using the SHA-1 secure hash algorithm; if you're using HMAC or RSA signature, you'll need to encode the signature.</p>
<p>Whether you are sending a hash or a signature, you'll need to convert the binary data to ASCII to be sent in the request message, using the Base64 encoding scheme.</p>
<table width="98%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table description">
<thead>
  <tr>
    <th width="60%">If you are using this security mechanism...</th>
    <th width="40%">Encode these parameters...</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>HMAC Signature with Shared Secret</td>
    <td><p>acmecorp_signature</p></td>
  </tr>
  <tr>
    <td>Hash/Digest with Shared Secret</td>
    <td><p>acmecorp_secret_digest</p></td>
  </tr>
  <tr>
    <td>RSA Signature with PKI</td>
    <td><p>acmecorp_signature</p></td>
  </tr>
</tbody>
</table>


<a name="compromise"></a><h4>What If the Private Key or Shared Secret Is Compromised?</h4>
<p>If for any reason you know or suspect that your app's Shared Secret or private key might have been compromised, you must replace with a new one immediately. You can generate a new Shared Secret in the platform; you must get a new private key from the issuing authority. Follow the applicable procedure below.</p>
<h5>To generate a new Shared Secret:</h5>
<ol>
  <li>Navigate to App Details &gt; Security Credentials.</li>
  <li>Click <strong>Regenerate Key</strong>.</li>
  <li>Copy the new key and use it in your app in place of the old one.</li>
</ol>
<p class="apidoc_note"><strong>Note</strong>: It might take up to five minutes for the new key to take effect. During that time, messages sent using the new key will fail. It's best to wait for five minutes before sending messages with the new key.</p>

<h5>To update your Private Key:</h5>
<ol>
  <li>Generate a new keypair.</li>
  <li>Update:
    <ul>
      <li>Upload the new key to the platform.</li>
      <li>Update your app to use the new key.</li>
    </ul>
    </li>
  <li>Test.</li>
</ol>

<!--<a name="differences"></a>
<h4>Differences between PKI-Based (Asymmetric) and Symmetric Key-Based Solutions</a></h4>
<p>Note: got this section from Mujeeb's page: https://pdolinux1/wiki/index.php/Application_Runtime_Security_%28Shared_Secret%29#differences_between_pki_based_and_symmetric_key_based_solutions</p>
<p>However some of the content is on the WEb.</p>
<p>Need to understand it and write something simple on this topic.</p>
<p>One resource that came up on a search for a snippet of the text below: http://pic.dhe.ibm.com/infocenter/tpfhelp/current/index.jsp?topic=%2Fcom.ibm.ztpf-ztpfdf.doc_put.cur%2Fgtps7%2Fs7symm.html.</p>
<p>With most symmetic-key algorithms, the same key is used for both encryption and decryption.</p>
<p>With symmetric-key encryption, the encryption key can be calculated from the decryption key and vice versa.</p>
<p>With Symmetric-key encryption, information encrypted with one symmetric key cannot be decrypted with any other symmetric key. The same key must be used.</p>
<p>PKI based encryption (also called asymmetric encryption) involves a pair of keys&#8212;a public key and a private key&#8212;associated with an entity that needs to authenticate its identity electronically or needs to sign or encrypt data. Data encrypted with your private key can be decrypted only with your public key and vice versa.</p>
<p>Compared with symmetric-key encryption, public-key encryption requires more computation. Implementations of symmetric-key encryption can be highly efficient, so that users do not experience any significant time delay as a result of the encryption and decryption. Symmetric-key encryption is effective only if the symmetric key is kept secret by the two parties involved. If anyone else discovers the key, it affects both confidentiality and authentication. A person with an unauthorized symmetric key not only can decrypt messages sent with that key, but can encrypt new messages and send them as if they came from one of the two parties who were originally using the key.</p>
<p>With public-key encryption, instead of encrypting the data itself, the signing software creates a one-way hash of the data, then uses the private key to encrypt the hash. The encrypted hash, along with other information, such as the hashing algorithm, is known as a digital signature. To validate the integrity of the data, the receiving software first uses the signer's public key to decrypt the hash. It then uses the same hashing algorithm that generated the original hash to generate a new one-way hash of the same data. If the two hashes match, the recipient can be certain that the public key used to decrypt the digital signature corresponds to the private key used to create the digital signature. The significance of a digital signature is comparable to the significance of a handwritten signature. Once you have signed some data, it is difficult to deny doing so later-assuming that the private key has not been compromised or out of the owner's control. This quality of digital signatures provides a high degree of nonrepudiation-that is, digital signatures make it difficult for the signer to deny having signed the data. In some situations, a digital signature may be as legally binding as a handwritten signature.</p>
-->



<p><a href="#top">Back to top</a></p>
<hr />



<a name="errors_all"></a><h3>Error Codes and Descriptions</h3>
<p>If there's a problem with your HTTPS header, you might see one of the error messages shown below.</p>
<table width="84%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table of error messages">
<thead>
  <tr>
    <th width="10%">Code</th>
    <th width="66%">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>1010701</td>
    <td>Required HTTP header parameter missing. [<strong>{0}</strong>]</td>
  </tr>
  <tr>
    <td>1010702</td>
    <td>One or more invalid HTTP header parameters.</td>
  </tr>
  <tr>
    <td>1010703</td>
    <td>Invalid <u>Nonce</u>. The value of the acmecorp_nonce field has already been used.</td>
  </tr>
  <tr>
    <td>1010704</td>
    <td>Invalid timestamp. The value of the acmecorp_timestamp field is out of range.</td>
  </tr>
  <tr>
    <td>1010705</td>
    <td>Signature or digest algorithm is not supported. [<strong>{0}</strong>]</td>
  </tr>
  <tr>
    <td>1010706</td>
    <td>Signature or digest verification failed.</td>
  </tr>
  <tr>
    <td>1010707</td>
    <td>Missing nonce. The acmecorp_nonce field value is required.</td>
  </tr>
  <tr>
    <td>1010708</td>
    <td>Unable to verify signature. There is no public key associated with the app.</td>
  </tr>
  <tr>
    <td>1010709</td>
    <td>Authentication scheme is invalid or missing.</td>
  </tr>
  <tr>
    <td>1010710</td>
    <td>Invalid AppID. The value [{0}] in the acmecorp_app_id field is invalid or missing.</td>
  </tr>
  <tr>
    <td>1010711</td>
    <td>Unable to verify signature. There is no shared secret associated with the <u>app</u>.</td>
  </tr>
  <tr>
    <td>1010712</td>
    <td>Invalid timestamp. Timestamp must be Unix epoch time in milliseconds.</td>
  </tr>
</tbody>
</table>
<p><a href="#top">Back to top</a></p>
<hr />



</div>
