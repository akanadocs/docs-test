---
layout: page
title: Promotion Guide | Lifecycle Coordinator
description: Learn how to use the Lifecycle Coordinator feature to manage the promotion lifecycle
product: cm
category: learn
sub-nav-class: Lifecycle Coordinator
weight: 20
type: page
nav-title: LC Promotion Guide
---
<h2 id="top">Lifecycle Coordinator Promotion Guide</h2>
<p>Provides information about how to use the Lifecycle Coordinator feature to manage the promotion feature.</p>
<p><a href="promotion_samples.htm" class="button secondary">Sample Topologies</a></p>

<h5 class="stamp">API Platform Version: 8.4.3 and later</h5>
<div class = "divider1"></div>


<h3 style="color: gray;">Table of Contents</h3>
<ol class="table_of_contents">
	<li><a href="#overview">Overview</a></li>
	<li><a href="#core_components">Core Components and Component Interaction</a></li>
	<li><a href="#topology_model">Topology Model</a>
		<ol>
			<li><a href="#s03_01">Topology</a></li>
			<li><a href="#s03_02">Tenants</a></li>
			<li><a href="#s03_03">Environments</a></li>
			<li><a href="#s03_04">Promotion Profiles</a></li>
			<li><a href="#s03_05">Asset Filters</a></li>
			<li><a href="#s03_06">Rules</a></li>
			<li><a href="#s03_07_00">Asset Model</a></li>
		</ol>
	</li>
	<li><a href="#lc_installation">Lifecycle Coordinator Installation</a>
		<ol>
			<li><a href="#lc_install_zip">Getting the installation ZIP file</a></li>
			<li><a href="#lc_install_feature">Installing the Lifecycle Coordinator feature</a></li>
			<li><a href="#lc_install_db_notes">Checking for database-specific requirements</a></li>
			<li><a href="#lc_install_secure_api">Securing the Topology REST API</a></li>
			<li><a href="#com_soa_promotion">Remote container address (com.soa.promotion)</a></li>
			<li><a href="#com_akana_lifecycle_coordinator">Properties to secure the Topology REST API (com.akana.lifecycle.coordinator)</a> (8.4.15 and later)</li>
			<li><a href="#config_preserveKeys">Unique ID Mapping behavior</a></li>
			<li><a href="#config_defaultFromEmail">Default "From Email" setting</a></li>
			<li><a href="#config_tenant_synch_interval">Tenant Synchronization Interval</a> (8.4.16 and later)</li>
		</ol>
	</li>

	<li><a href="#topology_config">Topology Configuration</a>
		<ol>
			<li><a href="#s05_01">Tenants</a></li>
			<li><a href="#s05_02">Environments</a></li>
			<li><a href="#s05_03">Promotion Profiles</a></li>
			<li><a href="#s05_04">Rules</a></li>
			<li><a href="#s05_05">Filters</a></li>
			<li><a href="#s05_06">Organization Mapping</a> (8.4.13 and later)</li>
			<li><a href="#s05_approval_proc">Approval Processes</a> (2018.0.0 and later)</li>
			<li><a href="#s05_07">Policy Mapping</a> (8.4.16 and later)</li>
			<li><a href="#resource_mapping">Resource Mappings (Scope Mapping)</a> (2018.0.0 and later)</li>
			<li><a href="#asset_notification">Asset Notifications</a> (8.4.17 and later)</li>
			<li><a href="#properties_element">Properties</a> (8.4.17 and later)</li>
		</ol>
	</li>
	<li><a href="#dz_configurations">Deployment Zone Configurations</a>
(8.4.12 and later)
	<ol>
			<li><a href="#s06_01">Using Filters with Deployment Zone Configurations</a></li>
			<li><a href="#s06_02">Default Endpoint Propagation</a></li>
			<li><a href="#s06_03">Using Rules with Deployment Zone Configurations</a></li>
			<li><a href="#s06_04">Duplicate Endpoints</a></li>
		</ol>
	</li>
	<li><a href="#s08_03_environment_config">Environment Configuration</a>
		<ol>
		<li><a href="#s08_04_api_impl_profiles">API Implementation Profiles</a></li>
		</ol>
	</li>
	<li><a href="#topology_api">Topology API</a>
		<ol>
			<li><a href="#topologyapi_01">Finding the Topology API Documentation</a></li>
			<li><a href="#topologyapi_02">Using the Topology API</a></li>
		</ol>
	</li>
	<li><a href="#lm_console">Lifecycle Manager Console</a>
		<ol>
			<li><a href="#s07_01">Logging In</a></li>
			<li><a href="#s07_02">Viewing Assets and Iterations</a></li>
			<li><a href="#s07_03">Promotion Requests</a></li>
		</ol>
	</li>
	<li><a href="#env_decoupled_00">Support for Decoupled Environments in a Topology</a></li>
	<li><a href="#runtime_config">Defaulting API Settings using Runtime Configurations</a> (8.4.17 and later)
	<ol>
			<li><a href="#s08_01_create_asset">Creating a Runtime Configuration Asset</a></li>
			<li><a href="#s08_02_publishing">Publishing a Runtime Configuration Asset</a></li>
		</ol>
	</li>
	<li><a href="#s09_orchestrated">Appendix A: Promoting Orchestrated APIs</a>
		<ol>
			<li><a href="#s09_01_referenced_svcs">Referenced Services</a></li>
		</ol>
	</li>
	<li><a href="#app_b_client_apps">Appendix B: Support for client apps</a> (2018.0.0 and later)</li>
</ol>
<div class = "divider1"></div>



<h3 id="overview">Overview</h3>
<p>Promotion is the process of propagating versions of a software asset, such as an API, through a series of environments that correspond to the stages of the asset's lifecycle. For example, an API might originate in a development environment, be promoted on to a QA test environment, and finally be promoted to the production environment. Each environment has its own data model that is controlled independently. The Lifecycle Coordinator is a separate configurable component that governs the promotion process and the transfer of data between environments.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="core_components">Core Components and Component Interaction</h3>
<p>The core components in the promotion process are as follows:</p>
<ul>
	<li><a href="#promotion_package">Promotion Package</a></li>
	<li><a href="#source_environment">Source Environment</a></li>
	<li><a href="#target_environment">Target Environment</a></li>
	<li><a href="#lifecycle_coordinator">Lifecycle Coordinator</a></li>
</ul>
<h4 id="promotion_package">Promotion Package</h4>
<p>The Promotion Package holds the data that needs to be promoted from the Source Environment to the Target Environment. The package contains two different artifacts:</p>
<ul>
	<li><strong>The environment data</strong>: The portion of the Source Environment's data model that needs to be promoted.</li>
	<li><strong>A manifest</strong>: Contains configuration details that can be manipulated by rules within the Coordinator before importing the package into the target environment.</li>
</ul>


<h4 id="source_environment">Source Environment</h4>
<p>The Source Environment is the data container that holds the original information that needs to be promoted to the Target Environment. The Source Environment can be managed by its own product instance or it can be managed as a single tenant in a multi-tenant product instance.</p>

<h4 id="target_environment">Target Environment</h4>
<p>The Target Environment is the data container that is the destination of the promoted data from the Source Environment. The Target Environment can be managed by its own product instance or it can be managed as a single tenant in a multi-tenant product instance.</p>

<h4 id="lifecycle_coordinator">Lifecycle Coordinator</h4>
<p>The Lifecycle Coordinator is the component that requests an extraction, or export, of a promotion package from a Source Environment and then initiates the population, or import, of the promotion package to a Target Environment.</p>
<p>The Coordinator processes the manifests contained in the Promotion Package and in the Target Environment's promotion response to maintain a model that reflects the relationship between objects in both environments. On subsequent promotions of the same objects from the Source Environment the Coordinator consults its model and generate a new manifest that will be delivered to the Target Environment.</p>
<p>The Lifecycle Coordinator is a separate component from the environments but can be co-deployed on the same instance.</p>

<h4>Component Interaction</h4>
<p><img src="images/promotion_01.jpg" alt="Component interaction" /></p>
<p>When promotion is requested from the Source Environment, the Lifecycle Coordinator exports a Promotion Package from that Environment and imports the package in the Target Environment.</p>
<p>The Lifecycle Coordinator persists its own model of objects and their relationships in all the environments it has performed promotions for. The Coordinator consults its model to see if the objects identified in the Promotion Package's manifest are already present. If the objects are not in the model, the Coordinator adds them. If the objects are in the model the Coordinator extracts the corresponding object IDs of the Target Environment and create a new manifest with the Target Environment's object IDs.</p>
<p>The Lifecycle Coordinator initiates an import of the Promotion Package in the Target Environment using an Import API. The Target Environment uses the manifest to identify the objects in its own data model that are in the Promotion Package; if objects already exist, a Modify action is performed. If the Promotion Package objects are new to the Target Environment an Add action is performed. The object IDs in the manifest are used in the Target Environment, not the object IDs found in the export content, which are still the IDs found in the Source Environment.</p>
<p>Upon completion of the Import API call a response is returned to the Lifecycle Coordinator. A manifest is included in that response that identifies the objects and relationships that were the result of the import in the Target Environment. The Lifecycle Coordinator processes this manifest and updates its own model for subsequent promotion calls.</p>
<p>The Lifecycle Coordinator can be deployed in a container separate from the API Platform(s) it governs promotions over. In this deployment, the interactions between the Lifecycle Coordinator and API Platform(s) are performed using RESTful interfaces. The Coordinator can promote between environments in the same system:</p>
<p><img src="images/promotion_02.jpg" alt="Environments in the same system" /></p>
<p>Or the Coordinator can promote between environments in separate systems.</p>
<p><img src="images/promotion_03.jpg" alt="Environments in different systems" /></p>
<p>The Lifecycle Coordinator can also be deployed in the same container as the API Platform. Whether multiple tenants are associated with Environments or just one tenant the deployment and interaction is the same. All interactions are performed using in-memory interfaces.</p>
<p><a href="#top">Back to top</a></p>




<h3 id="topology_model">Topology Model</h3>

<h4 id="s03_01">Topology</h4>
<p>A Topology defines a sequence of Environments and the specific behavior for promotion between these Environments.</p>
<p><img src="images/promotion_04.jpg" alt="Promotion behavior between environments" /></p>

<h4 id="s03_02">Tenants</h4>
<p>Tenants are defined at the top level of the Topology and represent a Community Manager (CM) tenant that may be local (within the same container) or remote from the Lifecycle Coordinator. Tenants are referenced by Environments via an id assigned to the tenant in its definition. While an Environment must reference a tenant, the same Tenant may be referenced by more than one Environment. Tenants contain information allowing the Lifecycle Coordinator to communicate with the associated CM Tenant, this includes the tenant's address, name and admin credentials.</p>
<p>A Tenant that is local may also indicate that it should be used to as an authentication source for users approving promotion requests with the Lifecycle Coordinator.</p>

<h4 id="s03_03">Environments</h4>
<p>An Environment represents a logical container to which an asset is deployed at a specific stage of its lifecycle. An Environment must specify the Tenant that supports it.</p>
<p>Environments also define the possible transitions to the next Environment in the form of Promotion Profiles. At this time, only a single target Environment can be specified in the promotion chain (Environment fan-out is not currently supported).</p>

<h4 id="s03_04">Promotion Profiles</h4>
<p>Promotion Profiles represent a transition to the next (<strong>target</strong>) Environment. A promotionProfile specifies a target Environment and optionally a set of Rules to be applied to the manifest of the promotion package of the asset prior to promotion into the target Environment. A promotionProfile might also, optionally, specify an Asset Filter. This allows multiple promotionProfiles to be defined within an Environment with mutually exclusive filters, each with a different rule set. When promotion of an asset is requested from a source Environment, and more than one promotionProfile exists, the promotionProfile with an Asset Filter that the asset complies with is used. In the case where only one promotionProfile exists (with no Asset Filter specified), that promotionProfile is automatically selected for the promotion.</p>


<h4 id="s03_05">Asset Filters</h4>
<p>Asset Filters contain a set of criteria for the custom properties of the assets being promoted. For example, an API asset may use a custom property indicating that it is PCI compliant. An Asset Filter can define criteria for that property such that only API assets that are PCI compliant will match the filter. This Asset Filter can then be assigned to a Promotion Profile such that a different set of Rules are applied to PCI-compliant and non-compliant API assets.</p>
<p class="apidoc_note"><strong>Note</strong>: the use of Asset Filters requires custom properties to be enabled for the tenants involved in the promotion.</p>


<h4 id="s03_06">Rules</h4>
<p>A Promotion Profile may optionally contain a set of rules to guide the need for changes in relationships and properties when assets are promoted. A rule consists of a condition and a behavior. The rule is provided a context when evaluated made up of an asset's properties. The condition of the rule is a Boolean expression evaluated against that context. The behavior of the rule is an expression that alters that context. The expression language used by the rule engine is JEXL. A set of syntax examples can be found at <a href="#" title="https://commons.apache.org/proper/commons-jexl/reference/syntax.html" target="_blank">https://commons.apache.org/proper/commons-jexl/reference/syntax.html</a>. Each asset in a promotion package is run through the rule engine. If any asset meets the condition of the rule, the behavior is performed against it. Some examples of rules are below.</p
>
<table cellspacing="0px" class="doctable" style="width: 98%;">
	<thead>
		<tr>
			<th width="33%">Condition</th>
			<th width="33%">Behavior</th>
			<th width="33%">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>vsep.containerKey = "ND1"</td>
			<td>vsep.containerKey = "ND2"</td>
			<td>Changes hosting relationship from ND1 to ND2</td>
		</tr>
		<tr>
			<td>apiversion.implType = "Sandbox"</td>
			<td>vsep.containerKey = "ND2"</td>
			<td>Changes hosting relationship for sandbox implementations</td>
		</tr>
		<tr>
			<td>vsep.containerKey = "ND1" &amp;&amp; vsep.listenerName = "http"</td>
			<td>vsep.containerKey = "ND2";
vsep.listenerName = "https"</td>
			<td>Changes both the container and listener</td>
		</tr>
		<tr>
			<td>psep.url.startsWith("http://oldhost")</td>
			<td>psep.url.replace("http://oldhost", "http://newhost")</td>
			<td>Changes the host of a target endpoint</td>
		</tr>
		<tr>
			<td>apiversion.tags.contains("secret")</td>
			<td>apiversion.tags.add("probation")</td>
			<td>Adds a tag based on the presence of another.</td>
		</tr>
		<tr>
			<td>classifier:internal = "true"</td>
			<td>vsep.containerKey = "ND3"</td>
			<td>Sets container based on the value of a custom classifier</td>
		</tr>
	</tbody>
</table>

<h4 id="s03_07_00">Asset Model</h4>
<p>The Lifecycle Coordinator component is an extension of the Lifecycle Repository core functionality. As such, it uses an internal asset model to represent the topology and the assets promoted through the topology. Within the Lifecycle Coordinator, promotion requests result in the submission of an asset into the target environment, allowing for customized governance to be defined for this process.</p>
<p>In this section:</p>
<ul>
	<li><a href="#s03_07_01">Topology Asset Model</a></li>
	<li><a href="#s03_07_02">Promotable Asset Model</a></li>
	<li><a href="#s03_07_03">OrgGroup Assignment</a></li>
</ul>

<h5 id="s03_07_01">Topology Asset Model</h5>
<p>The topology asset model reflects the conceptual topology model defined earlier in this document with asset types for Environment, Tenant and Promotion Profile. The following diagram shows the asset structure for a Topology with three Environments (each box representing an asset):</p>
<p><img src="images/promotion_05.jpg" alt="Topology asset model, three environments" /></p>
<p>In addition to the relationships shown, Tenant assets contain connection information and credentials as classifiers while Promotion Profile assets hold Rules as a JSON artifact. Asset Filters are managed implicitly and optionally referenced by Promotion Profile assets.</p>


<h5 id="s03_07_02">Promotable Asset Model</h5>
<p>Promotable assets such as APIs are represented by specific asset-types. These asset types reference an Environment asset and contain <strong>Iteration</strong> assets representing each promotion of that asset. Note that there is a difference between <strong>versions</strong> of assets such as APIs and <strong>iterations</strong>: a single version of an API may be promoted multiple times, resulting in multiple iterations of that version. In the following asset diagram, the asset <strong>AnAPI (v1)</strong> has been promoted from development to integration test and then to production environments once, followed by another promotion from development to integration test. This resulted in two iterations in the development and integration test environments with a single iteration at production. Notice that the iteration at production indicates that its source iteration is iteration 1 in integration test, even though there is a newer iteration (iteration 2) in that environment.</p>
<p><img src="images/promotion_06.jpg" alt="Promotable asset model" /></p>
<p>Iterations contain several items:</p>
<ul>
	<li>A timestamp indicating when the promotion took place</li>
	<li>The user that requested the promotion</li>
	<li>The status of the promotion. Values for the status are:
		<ul>
			<li><strong>Promotion Pending</strong>: Promotion has been requested but has not been completed. It may be pending one or more approvals.
			<p><strong>Note</strong>: In the case where an approval process is in place and a promotion request is rejected, the Iteration will remain in a Promotion Pending state. However, the API platform UI will show it as <strong>Promotion Rejected</strong>, allowing promotion to be requested again.</p></li>
			<li><strong>Promoted</strong>: Promotion has completed.</li>
			<li><strong>Promotion Failed</strong>: There was a failure in the promotion process. Promotion can be requested again for assets in this state. The next promotion attempt will replace the failed iteration.</li>
		</ul>
			<p><strong>Note</strong>: The API Platform UI also indicates a <strong>Not Promoted</strong> state. This corresponds to an asset not yet existing in the target environment. Such assets will not be present in Lifecycle Coordinator.</p>
	</li>
	<li>The promotion package that was imported into the target environment is held as an artifact called archive.zip.</li>
	<li>In the case of a promotion failure the iteration includes a short summary of the exception causing the failure.</li>
	<li>A relationship to the source iteration in the source environment</li>
	<li>A relationship to the previous iteration (if one exists) in the target environment</li>
	<li>A relationship to the Promotion Profile selected for promotion of the asset.</li>
</ul>

<h5 id="s03_07_03">OrgGroup Assignment</h5>
<h5 class="stamp">API Platform Version: 8.4.13 and later</h5>
<p>When promotion is requested for an asset such as an API, the asset is assigned an owning OrgGroup within Lifecycle Coordinator. These OrgGroups correspond to the asset's Organization in the corresponding API Platform environment. This approach allows promotion approvers to be assigned at an organizational level within the Lifecycle Coordinator topology.</p>
<span class="apidoc_note"><strong>Note</strong>: OrgGroups are synchronized with the tenant Organization when a topology is created or updated. If an asset is promoted with an Organization for which there is no corresponding OrgGroup, Lifecycle Coordinator synchronizes the Organizations for the corresponding tenant in an attempt to resolve the missing OrgGroup.</span>
<p><a href="#top">Back to top</a></p>




<h3 id="lc_installation">Lifecycle Coordinator Installation</h3>
<p>This section includes:</p>
<ul>
	<li><a href="#lc_install_zip">Getting the installation ZIP file</a></li>
	<li><a href="#lc_install_feature">Installing the Lifecycle Coordinator feature</a></li>
	<li><a href="#lc_install_db_notes">Checking for database-specific requirements</a></li>
	<li><a href="#lc_install_secure_api">Securing the Topology REST API</a></li>
	<li><a href="#com_soa_promotion">Remote container address (com.soa.promotion)</a></li>
	<li><a href="#com_akana_lifecycle_coordinator">Properties to secure the Topology REST API (com.akana.lifecycle.coordinator)</a></li>
	<li><a href="#config_preserveKeys">Unique ID Mapping behavior</a></li>
	<li><a href="#config_defaultFromEmail">Default "From Email" setting</a></li>
	<li><a href="#config_tenant_synch_interval">Tenant Synchronization Interval</a></li>
</ul>


<h4 id="lc_install_zip">Getting the installation ZIP file</h4>
<p>For versions prior to 2018.0.0, if you're installing Lifecycle Coordinator, you'll need a specific ZIP file in addition to the main ZIP files for Akana API Platform installation.</p>
<p>In version 2018.0.0 and later, Lifecycle Coordinator is part of the main Akana API Platform ZIP file; you don't need any additional ZIP file.</p>
<p>Log in to the Rogue Wave Support Center (<a href="https://library.roguewave.com" target="_blank">https://library.roguewave.com</a>).</p>
<p>In the <strong>My Resources section</strong>, click <strong>Product Downloads</strong>, then click <strong>Akana - Product Downloads</strong>. Download the applicable <strong>lifecyclemanagerplatform_8.4.xx.xxxxx.zip</strong> file for Lifecycle Manager; for example, <strong>lifecyclemanagerplatform_8.4.16.02264.zip</strong> file.</p>


<h4 id="lc_install_feature">Installing the Lifecycle Coordinator feature</h4>
<p>For an on-premise installation of the Akana API Platform, the Lifecycle Coordinator feature must be separately installed from the Akana Administration Console:</p>
<p><img src="images/promotion_07.jpg" alt="Lifecycle Coordinator feature" /></p>
<p>Installing Lifecycle Coordinator implicitly installs the Lifecycle Repository feature as well. After selecting Lifecycle Coordinator for installation, the user is guided through a number of configuration tasks for the Lifecycle Repository feature.</p>


<h4 id="lc_install_db_notes">Checking for database-specific requirements</h4>
<p>Depending on the database version you're using, there might be additional steps you need to take. You should perform these steps after installation and before the additional configuration steps.</p>
<p>For details of the requirements for specific database types and versions, refer to the <a href="../../sp/platform_install/installing_akana_api_platform_v84.htm#database_notes">database notes</a> section of the Akana API Platform installation documentation. Specifically, there are notes for Microsoft SQL Server and MySQL relating to installation of Lifecycle Repository.</p>
<p>Complete any applicable steps before continuing.</p>


<h4 id="lc_install_secure_api">Securing the Topology REST API</h4>
<p>There is also a task to secure the Topology REST API, as shown below.</p>
<p><img src="images/promotion_08.jpg" alt="Set Topology API Credentials task" /></p>
<p>This sets up the credentials for basic authentication on calls to the Topology REST API.</p>


<h4 id="com_soa_promotion">Remote container address (com.soa.promotion)</h4>
<p>If the Lifecycle Coordinator is installed remotely, a URL to the remote container hosting the Lifecycle Coordinator instance must be configured for each container hosting tenants from which promotion can be requested.</p>
<p>To set this up:</p>
<ol>
	<li>In the Akana Administration Console, open the <strong>Configuration</strong> tab.</li>
	<li>Select the <strong>com.soa.promotion</strong> category.</li>
	<li>Set the <strong>remote.promoter.address</strong> property to the host address of the container hosting the Lifecycle Coordinator instance. An example is shown below.
<p><img src="images/promotion_09.jpg" alt="Setting remote.provider.address" /></p></li>
	<li>Save the changes.</li>
</ol>

<h4 id="com_akana_lifecycle_coordinator">Properties to secure the Topology REST API (com.akana.lifecycle.coordinator)</h4>
<p class="stamp">API Platform Version: 8.4.15 and later</p>
<p>You can set up the global configuration properties for Lifecycle Coordinator in the Akana Admin Console.</p>
<p>With the three properties listed below, you can configure the Topology REST API to require basic authentication for all requests.</p>
<ol>
	<li>In the Akana Administration Console, open the <strong>Configuration</strong> tab.</li>
	<li>Select the <strong>com.akana.lifecycle.coordinator</strong> category.</li>
	<li>Set the properties. For details, see <a href="#lc_property_details">com.akana.lifecycle.coordinator properties</a> below.</li>
	<li>Save the changes.</li>
</ol>
<h5 id="lc_property_details"><strong>com.akana.lifecycle.coordinator</strong> properties</h5>
<dl>
<dt>lifecycle.coordinator.config.apiUser</dt>
<dd>This field and the next are used to set the <strong>global</strong> basic authentication credentials for the Topology REST API. If this property is left empty, the Topology API will not require authentication of requests.</dd>
<dt>lifecycle.coordinator.config.apiPassword properties</dt>
<dd>If a value was set for lifecycle.coordinator.config.apiUser, specify the password.</dd>
<dt>lifecycle.coordinator.config.enableTenantScopedAuthentication</dt>
<dd>Boolean. Used to allow delegation of authentication to the primary tenant in the topology being acted on. The primary tenant is the tenant marked as the <strong>userAuthenticationSource</strong> in the topology. If no tenant is marked as the userAuthenticationSource, the initial tenant in the topology is used for authentication.</dd>
</dl>

<p>The following table summarizes the authentication behavior.</p>
<table cellspacing="0px" class="doctable" style="width: 98%;">
	<thead>
		<tr>
			<th width="20%">Global Credentials Set</th>
			<th width="20%">Tenant Scoped Authentication Enabled</th>
			<th width="59%">Behavior</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>No</td>
			<td>N/A</td>
			<td>Requests are not authenticated</td>
		</tr>
		<tr>
			<td>Yes</td>
			<td>false</td>
			<td>Requests must specify global credentials</td>
		</tr>
		<tr>
			<td>Yes</td>
			<td>true</td>
			<td><p>Requests can specify either of these:</p>
				<ul>
					<li>The email and password of a site admin user in the primary tenant of the topology being acted on.</li>
					<li>The global credentials</li>
				</ul></td>
		</tr>
	</tbody>
</table>


<p><strong>Note</strong>: Requests for the <strong>getTopologies</strong> method (<span class="apidoc_code">GET /lc/api/topologies</span>) must specify the global credentials since there is no specific topology being acted on.</p>


<h4 id="config_preserveKeys">Unique ID Mapping behavior</h4>
<p><span class="stamp">API Platform Version: 8.4.14 and later</span>. Updated for 2018.0.0.</p>
<p>When a source and target environment exist in the same API Platform instance, it is necessary to assign new unique IDs (keys) to the internal objects, such as services, that make up an API or app being promoted. This is because the keys must be unique across the API Platform instance, regardless of which tenant they exist in.</p>
<p>By default, Lifecyle Coordinator determines whether to preserve the keys of the promoted objects, or to assign new keys, based on whether the source and target environments exist in the same API Platform instance:</p>
<ul>
	<li>If the source and target environments coexist in the same API Platform instance, the platform assigns new keys.</li>
	<li>If the source and target environments are in different API Platform instances, the platform preserves the original keys from the source environment.</li>
</ul>
<p>In certain situations, it might be necessary to override the default key handling behavior. For example, assume that environment A is in one API Platform instance and environments B and C coexist in another API Platform instance. If a topology is configured to promote from environment A to environments B and C in parallel, the default key handling algorithm will attempt to assign the same keys to objects promoted to each environment, B and C. The result would be that one of the promotions would fail. In this case, you can override the default key handling behavior by setting the <strong>preserve-keys</strong> property on one of the Promotion Profiles involved.
	For example, the Promotion Profiles for environment A would be configured as shown below.</p>
<pre>"promotionProfiles": [
{
    "name": "B Promotion",
    "targetEnvironment": "B"
  },
  {
    "name": "C Promotion",
    "targetEnvironment": "C",
    "properties" : [
      {"name":"preserve-keys","value":"false"}
    ]
  } 
]</pre>
<p>With this approach, the promoted keys in environment B would match those of the source, while environment C would have new keys assigned, eliminating conflict between the two co-located target environments.</p>
<p><strong>Note</strong>: Be cautious in using the <strong>preserve-keys</strong> property. If the source and target environments are on the same API Platform instance, and the property is set to <strong>true</strong>, promotions will fail.</p>


<h4 id="config_defaultFromEmail">Default "From Email" setting</h4>
<p>You can set the default <strong>from</strong> email address used in emails sent from Lifecycle Coordinator, in the <strong>repository.config.defaultFromEmail property</strong> of the <strong>com.soa.repository</strong> configuration category.</p>
<p>You can also override the <strong>from</strong> email address for a specific topology. To do this, go into the topology library as an admin user or superuser, click <strong>Support Center</strong>, click <strong>Configure Library</strong> and set the <strong>Sender Email</strong> field, as shown below.</p>
<p><img src="images/promotion_lm_from_email.jpg" alt="Setting From Email in LM" /></p>


<h4 id="config_tenant_synch_interval">Tenant Synchronization Interval</h4>
<h5 class="stamp">API Platform Version: 8.4.16 and later</h5>
<p>Lifecycle Coordinator periodically updates cached policy and organization information for tenants referenced in a topology. The specific interval for this update is controlled by the following property:</p>
<dl>
<dt>Configuration category</dt>
<dd>com.soa.repository</dd>


<dt>Configuration property</dt>
<dd>repository.config.tenantSyncInterval</dd>


<dt>Explanation:</dt>
<dd>Sets the interval between updates to cached policy and organizational information. The value is set in milliseconds.</dd>


<dt>Default value:</dt>
<dd>300000 (5 minutes)</dd>
</dl>
<p><a href="#top">Back to top</a></p>



<h3 id="topology_config">Topology Configuration</h3>
<p>The Lifecycle Coordinator feature provides a REST API for maintaining topologies. This allows topologies to be defined in JSON structure. The following example shows the definition of a topology consisting of two environments supported by two local tenants.</p>
<pre>{
  "name":"Topology1",
  "tenants":[
    {
      "name":"DevelopmentTenant",
      "id":"tenant1",
      "credentials":{
        "email":" administrator1@example.com ",
        "password":"password1"
      }
    },
    {
      "name":"ProductionTenant",
      "id":"tenant2",
      "userAuthenticationSource":true,
      "credentials":{
        "email":"administrator2@example.com",
        "password":"password2"
      }
    }
  ],
  "environments":[
    {
      "name":"development",
      "displayName":"Development",
      "description":"Development environment",
      "tenant":"DevelopmentTenant",
      "promotionProfiles":[
        {
          "name":"Default Production Promotion",
          "description":"Dev to production default profile",
          "targetEnvironment":"production"
        }
      ]
    },
    {
      "name":"production",
      "displayName":"Production",
      "description":"Production environment",
      "tenant":"ProductionTenant"
    }
  ]
}</pre>



<h4 id="s05_01">Tenants</h4>
<p>This section includes:</p>
<ul>
	<li><a href="#s05_01_tenantdefinitions">Tenant Definitions</a></li>
	<li><a href="#s05_01_tenantnames">Tenant Names</a></li>
	<li><a href="#s05_01_delegatedauth">Delegated Authentication</a></li>
	<li><a href="#s05_01_tenantproperties">Tenant Properties (8.4.18 and later)</a></li>
</ul>
<h5 id="s05_01_tenantdefinitions">Tenant Definitions</h5>
<p>Tenant definitions in the topology provide the Lifecycle Coordinator the necessary information to communicate with the specified tenant. Tenants can be either local (on the same container as the Lifecycle Coordinator) or remote. When defining a tenant:</p>
<ul>
	<li><strong>Local</strong> tenant: Specify the tenantId in the <strong>id</strong> property, as in the topology example above.</li>
	<li><strong>Remote</strong> tenant: In addition to the tenantId in the <strong>id</strong> property as above, specify the address of the tenant in the <strong>address</strong> field.</li>
</ul>
<p>The example below shows both values:</p>
<pre>{
  "name":"ProductionTenant",
  "id":"tenant2",
  "address":"http://myProductionTenant:9900",
  "credentials":{
    "email":"administrator2@example.com",
    "password":"password2"
  }
}</pre>
<p class="apidoc_note"><strong>Note</strong>: The address value is unique to the tenant. It corresponds to the value specified for the <strong>address</strong> parameter when the tenant was created.</p>

<h5 id="s05_01_tenantnames">Tenant Names</h5>
<p>Tenants require a <strong>name</strong> property which is used to identify the tenant by environments within the topology. This name must be unique within the topology, but need not correspond to the actual tenant name.</p>

<h5 id="s05_01_delegatedauth_pre_2018">Delegated Authentication</h5>
<p>In the promotion profile, you can indicate that authentication for the underlying Lifecycle Repository library is delegated to a specified tenant. This means that users of the specified tenant can log in to the topology library using their email and password for that tenant.</p>
<p>There are two ways you can do this:</p>
<ol>
	<li>By using the <strong>userAuthenticationSource</strong> property.
		<p>You can set the Boolean <strong>userAuthenticationSource</strong> property within a Tenant definition to indicate that the tenant will be used for authentication.</p>
<p>Only one tenant can have the <strong>userAuthenticationSource</strong> property set to <strong>true</strong>, and that tenant must be local to the Lifecycle Coordinator. This delegates user definition and authentication to the specified local tenant (a tenant in the same container that Lifecycle Coordinator is deployed in).</p>
<p>An example is shown below.</p>
<pre>{ 
  &quot;name&quot;:&quot;DevelopmentTenant&quot;,
  &quot;id&quot;:&quot;tenant1&quot;,
  &quot;credentials&quot;:{ 
    &quot;email&quot;:&quot;administrator1@roch.soa.local&quot;,
    &quot;password&quot;:&quot;password1&quot;
  },
  &quot;userAuthenticationSource&quot;:true
},</pre>
</li>
	<li>By setting a tenant ID using the topology-scoped <strong>authentication-tenant-id</strong> property. (2018.0.0 and later)
	<p>In version 2018.0.0, Lifecycle Coordinator relies on the Akana API Platform for user authentication. Since Lifecycle Coordinator is often deployed separately from tenants in the topology, it might be necessary to delegate authentication and user management to a local tenant that is not in the topology.</p>
	<p>A tenant specified with the <strong>authentication-tenant-id</strong> property must be local, but doesn't need to be part of the topology.</p>
	<p>An example is shown below.</p>
	<pre>{
  "name": "Topology1",
  "properties": [
    {"name":"authentication-tenant-id","value":"authtenant"}
  ],
...</pre>
	</li>
</ol>
<p>If neither of these approaches is used to specify the authentication tenant, the authentication tenant ID defaults to <strong>lifecycle_coordinator</strong>.</p>
<h5 id="s05_01_tenantproperties">Tenant Properties (8.4.18 and later)</h5>
<p>Tenant definitions can contain optional properties, as shown in the example below.</p>
<pre>{
  "name":"ProductionTenant",
  "id":"tenant2",
  "address":"http://myProductionTenant:9900",
  "credentials":{
    "email":"administrator2@example.com",
    "password":"password2"
  },
  "properties":[
    {
      "name":"virtual-address",
      "value":"http://myCompany:9950"
    }
  ]
}</pre>
<p>The optional properties available for a tenant are:</p>
<ul>
	<li><strong>virtual-address</strong>: This property can be used when the URL used to access a remote tenant is different from the tenant's address attribute. For example, this property would be used if the tenant is fronted by a load balancer. If the <strong>virtual-address</strong> property is provided, the URL set in the value of this property is used for all communications with the tenant.</li>
</ul>


<h4 id="s05_02">Environments</h4>
<p>Environments reference a corresponding tenant and hold one or more promotionProfiles representing transitions to other environments.</p>


<h5>Environment Names</h5>
<p>The <strong>name</strong> property for an environment must be unique within the topology and should not be changed once defined. This is because this name is used as a key for mapping information between environments stored by the Lifecycle Coordinator. Given the invariability of the environment name, a <strong>displayName</strong> property is also supported. The display name is what appears to users in the API Platform UI and may be changed without affecting mapping information.</p>

<h4 id="s05_03">Promotion Profiles</h4>
<p>Promotion Profiles are defined within the <strong>promotionProfiles</strong> property of an Environment. The <strong>targetEnvironment</strong> property of a PromotionProfile must correspond to the <strong>name</strong> of another Environment in the Topology.</p>
<p>A PromotionProfile can optionally specify one or more filters by specifying filter names within the <strong>filterNames</strong> array property.</p>
<p>Rule definitions might optionally be provided using the <strong>rules</strong> array property.</p>
<p class="apidoc_note"><strong>Note</strong>: A PromotionProfile cannot create a cycle between Environments.</p>


<h4 id="s05_04">Rules</h4>
<p>Rules are defined inline within the <strong>rules</strong> array property of a PromotionProfile. Each Rule consists of a <strong>scope</strong> property indicating the property in the archive manifest it applies to, an optional <strong>condition</strong> property indicating the conditions for which the Rule applies and a required <strong>action</strong> property indicating the action to perform on the manifest property.</p>
<p>Examples in this section:</p>
<ul>
	<li><a href="#s05_04_01">Rule example #1</a>: changes the hostname for the physical service endpoint.</li>
	<li><a href="#s05_04_02">Rule example #2</a>: changes the name of the OAuth provider for a promoted API in the target environment.</li>
</ul>
<h5 id="s05_04_01">Rule example #1</h5>
<p>In this example, the rule changes the host name of the physical service endpoint (<strong>psep</strong>) for an API:</p>
<pre>{
  "scope":"psep",
  "condition":"psep.url.indexOf(\"foo.com\") > 0",
  "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
}</pre>
<p>Note the use of '\' to escape the double quotes in the condition and action.</p>

<h5 id="s05_04_02">Rule example #2</h5>
<p>The example below changes the name of the OAuth provider for a promoted API in the target environment.</p>
<p><strong>Note</strong>: Only use this rule if the configuration of the source and target OAuth Providers is identical, including scope definition. If the configuration is not identical, using this rule might cause promotion errors.</p>
<pre>{
  "scope" : "vs",
  "condition" : "vs.oauthProvider == 'SourceProvider'",
  "action" : "vs.oauthProvider = 'TargetProvider'"
}</pre>


<h4 id="s05_05">Filters</h4>
<p>The <strong>filters</strong> property of a Topology allows asset filters to be defined for use in PromotionProfile selection. Filters contain criteria which apply to the classifiers associated with an asset.</p>
<p>Filters correspond to the <strong>custom properties</strong> for an API in the API Platform UI.</p>
<p>The following example defines filters used to differentiate between APIs that are PCI compliant and those that are not based on a <strong>pci-compliant</strong> classifier:</p>
<pre>[
  {
    "name":"PCI Compliant",
    "classifier-criteria":[
      {
        "classifierName":"pci-compliant",
        "values":[
          {
            "value":"true"
          }
        ]
      }
    ]
  },
  {
    "name":"PCI Non-Compliant",
    "classifier-criteria":[
      {
        "classifierName":"pci-compliant",
        "values":[
          {
            "value":"false"
          }
        ]
      }
    ]
  }
]
</pre>
<p>With these filters defined, different transition paths between source and target Environments can be defined as in the following example <strong>promotionProfiles</strong> property for an Environment:</p>
<pre>{
  "promotionProfiles":[
    {
      "name":"PCI Production Promotion",
      "targetEnvironment":"Production",
      "filterNames":[
        "PCI Compliant"
      ],
      "rules":[
        {
          "scope":"vsep",
          "action":"vsep.containerKey = '{pci-container-key}' "
        }
      ]
    },
    {
      "name":"Non-PCI Production Promotion",
      "targetEnvironment":"Production",
      "filterNames":[
        "PCI Non-Compliant"
      ],
      "rules":[
        {
          "scope":"vsep",
          "action":"vsep.containerKey = '{standard-container-key}' "
        }
      ]
    }
  ]
}</pre>
<p><a href="#top">Back to top</a></p>


<h4 id="s05_approval_proc">Approval Processes</h4>
<h5 class="stamp">API Platform Version: 2018.0.0 and later</h5>
<p>Simple approval processes involving one or two approver roles can be defined within a PromotionProfile using the <strong>approvalProcesses</strong> property to call out (in order) the approval roles for the promotion to the target environment. For example, the following PromotionProfile definition for transition to the production environment requires approval from a user with the <strong>Architect</strong> role, followed by approval from a user with the <strong>Promotion Manager</strong> role.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "approvalProcesses": [
    {
      "type": "api",
      "approvals": [
        "Architect",
        "Promotion Manager"
      ]
    }
  ]
}</pre>
<p>The specification of roles in the approvals property causes the specified roles to be implicitly created in the topology library, where users can then be assigned to the roles.</p>
<p>This declarative approach to approval definition is intended to address simple approval processes that do not required property-based filtering, require more than two approval roles, or require special pre- or post-processing tasks. To define advanced approval processes such as this, use Configuration Designer.</p>
<p>Note that if any PromotionProfile in the topology definition defines an approvalProcess, LifecycleCoordinator assumes that it is managing all submission processes and custom roles for the underlying library and overwrites any customization of those processes or manually defined roles. If the PromotionProfile includes advanced process configuration, do not include approvalProcesses in the topology definition.</p>
<p><a href="#top">Back to top</a></p>


<h4 id="s05_06">Organization Mapping</h4>
<h5 class="stamp">API Platform Version: 8.4.13 and later</h5>
<p>Lifecycle Coordinator attempts to assign APIs in the target environment tenant to an Organization matching the name of the Organization in the source environment tenant. If it doesn't find an Organization of the same name, it assigns the API to the tenant Organization.</p>
<p>Within a promotion profile, you can define a rule to create a mapping of Organizations when promoting to the target environment. To do this, define a rule that modifies the <strong>api.orgName</strong> property.</p>
<p>For example, you could add the following rule to the rules of a PromotionProfile to map APIs from the source Organization <strong>GroupA</strong> to the target Organization <strong>GroupB</strong>.</p>
<pre>{
  "scope":"api",
  "condition":"api.orgName == 'GroupA'",
  "action":"api.orgName = 'GroupB'"
}</pre>



<h4 id="s05_07">Policy Mapping</h4>
<h5 class="stamp">API Platform Version: 8.4.16 and later</h5>
<p>A Promotion Profile can optionally contain a set of PolicyMappings that you can use to tailor the propagation and validation of policy references when an API is promoted to the target environment. You can use PolicyMappings to:</p>
<ul>
	<li>Map a policy reference in the source environment to a policy in the target environment.</li>
	<li>Remove a policy reference altogether when an API is promoted.</li>
</ul>
<p>A PolicyMapping has one of these two properties:</p>
<ul>
	<li><strong>sourcePolicy</strong>&#8212;Used to identify a specific policy in the source environment by either name or unique id.</li>
	<li><strong>sourcePolicyFilter</strong>&#8212;Used to specify a group of policies by type or subtype.</li>
</ul>
<p>Additionally, a PolicyMapping can specify a <strong>targetPolicy</strong> in the target environment either by name or unique id.	If a PolicyMapping does not specify a <strong>targetPolicy</strong> property, references to policies matching the <strong>sourcePolicy</strong> or <strong>sourcePolicyFilter</strong> property are ignored when an API is propagated to the next environment.</p>
<p>The following PromotionProfile shows an example of a PolicyMapping that maps references to the DetailedAuditPolicy in the source environment to the BasicAuditPolicy in the target environment:</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "rules": [],
  "policyMappings": [
    {
      "sourcePolicy": {
        "policyName": "DetailedAuditing"
      },
      "targetPolicy": {
        "policyName": "BasicAuditing"
      }
    }
  ]
}</pre>

<p>In this example, the PolicyMapping uses the unique ids of the source and target policies:</p>
<pre>{
  "sourcePolicy": {
    "policyId": "urn:uuid:852afbc5-101e-11e8-887b-abe2ebb3db33"
  },
  "targetPolicy": {
    "policyId": "urn:uuid:763b7ca5-304f-16e8-457b-c542e456db33"
  }
}</pre>
<p>You can accomplish a  one-to-many mapping of policies using a policy filter:</p>
<pre>{
  "sourcePolicyFilter": {
    "policyType": "Operational Policy",
    "policySubtype" : "policy.auditservice"
  },
  "targetPolicy": {
    "policyName": "BasicAuditing"
    }
}</pre>
<p>A specific policy is disabled on promotion by omitting the targetPolicy property in the PolicyMapping:</p>
<pre>{
  "sourcePolicy": {
    "policyName": " DetailedAuditing "
  }
}</pre>

<h5>Default Mappings</h5>
<p>Policies that are available by default within a tenant, such as DetailedAuditing, BasicAuditing, and CORSAllowAll, are implicitly mapped to the corresponding default policies in the target tenant and do not need an explicit PolicyMapping. You can think of this default mapping as being of the form:</p>
<pre>{
  "sourcePolicy": {
    "policyId": "&lt;source tenant id&gt;-&lt;policy name&gt;"
  },
  "targetPolicy": {
    "policyId": "&lt;target tenant id&gt;-&lt;policy name&gt;"
  }
}
</pre>

<h5 id="s05_07_03">Tenant name change: original-tenant-name property</h5>
<p>Default policy mappings are determined based on the tenant name. If the name of a tenant was changed since its original creation (in the Developer Portal, <strong>Admin</strong> > <strong>Site</strong>), it's important to include the original tenant name in the tenant definition in the topology, using the <strong>original-tenant-name</strong> property. An example is shown below.</p>
<pre>{ 
  "id": "devtenant", 
  "name": "DevelopmentTenant", 
  "address": "http://devacmepaymentscorptenant:9457", 
  "properties": [ 
    { 
      "name": "original-tenant-name", 
      "value": "Tenant1" 
    } 
  ], 
  ... 
}</pre>


<h5>Policy Validation</h5>
<p>When an API is promoted, policy references must do one of the following:</p>
<ul>
	<li>Reference a default policy, such as DetailedAuditing</li>
	<li>Match the unique ID of an existing policy in the target environment</li>
	<li>Match a PolicyMapping defined for the selected PromotionProfile </li>
</ul>
<p>If none of the above criteria are met, a validation error is returned to the promoting user and the promotion is aborted.</p>
<p><a href="#top">Back to top</a></p>


<h4 id="resource_mapping">Resource Mappings (Scope Mapping)</h4>
<h5 class="stamp">API Platform Version: 2018.0.0 and later</h5>
<p>A PromotionProfile can, optionally, include a set of ResourceMappings that can be used to tailor the propagation and validation of resource references representing the <strong>scopes</strong> assigned to an API and its operations as the API is promoted to the target environment.</p>
<p>A ResourceMapping consists of a <strong>sourceResource</strong> and a <strong>targetResource</strong> property, each specifying either the name or ID of a resource in the respective environment. The following PromotionProfile shows an example of a ResourceMapping that maps a resource (scope) by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "resourceMappings": [
    {
      "sourceResource": {"resourceName" : "DevScope1"},
      "targetResource": {"resourceName" : "ProdScope1"}
    }
  ]
}</pre>
<p>Resource mapping can also be done with unique IDs. In the example below, the ResourceMapping uses the unique IDs of the source and target resources.</p>
<pre>{
  " sourceResource ":{
    "resourceId":"aa6d2ae0-299d-47d1-a899-f7e6be1b781a.tenant1"
  },
  " targetResource ":{
    "resourceId":"3456bae0-299d-47d1-7799-f7e6be1b221a.tenant2"
  }
}</pre>

<h5 id="resource_mapping_default">Default Mapping</h5>
<p>By default, Lifecycle Coordinator maps resources (scopes) based on matching names. This means that references from an API to a scope in the source environment will be mapped to a scope of the same name (if it exists) in the target environment regardless of the IDs of the scopes. You can change this default behavior by setting the <strong>match-resources-by-name</strong> property on the PromotionProfile to <strong>false</strong> as shown below.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties": [
    {"name": "match-resources-by-name","value": "false"}
  ]
}</pre>

<h5 id="resource_validation">Resource Validation</h5>
<p>By default, if a resource referenced by an API or its operations does not match a resource in the target environment (either by ID, by resource mapping, or by default name matching behavior), promotion of the API will proceed without error with the resource reference removed from the promoted API.</p>
<p>You can change this behavior by setting the <strong>validate-api-resources</strong> property on the PromotionProfile to <strong>true</strong>, as shown in the example below.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties": [
    {"name": "validate-api-resources","value": "true"}
  ]
}</pre>
<p>With the <strong>validate-api-resources</strong> property set to <strong>true</strong>, promotion of an API with an unmatched resource reference will be aborted. A validation error is displayed to the user attempting to promote the resource.</p>


<h4 id="asset_notification">Asset Notifications</h4>
<h5 class="stamp">API Platform Version: 8.4.17 and later</h5>
<p>A PromotionProfile can optionally specify updates to be made to instances of an API, within environments of a topology, on completion of a successful promotion. These updates are implemented as changes to the values of custom properties on the API within a specified environment.</p>
<p>For example, let's assume a topology consisting of three environments: <strong>Development</strong>, <strong>Test</strong>, and <strong>Production</strong>. The goal is to mark the instances of an API in the Development and Test environments as <strong>in production</strong> once the API is successfully promoted to the Production environment.</p>
<p>Steps:</p>
<ol>
	<li>The Development and Test tenants could be configured to support an <strong>in-production</strong> Boolean custom property.</li>
	<li>Then, the PromotionProfile representing the promotion from Test to Production would specify the property to update, the value to set the property to, and the environments in which the property is to be set.</li>
</ol>
<p>This is shown in the following PromotionProfile declaration:</p>
<pre>{
  "name":"Default Production Promotion",
  "targetEnvironment":"production",
  "assetNotifications":[
    {
      "propertyName":"in-production",
      "propertyValue":"true",
      "environments":[
        "development",
        "test"
      ]
    }
  ]
}</pre>
<p>This feature relies on custom properties having been enable for the notified tenants, and on the specified property existing on the target API.</p>


<h4 id="properties_element">Properties</h4>
<h5 class="stamp">API Platform Version: 8.4.17 and later</h5>
<p>A PromotionProfile can optionally specify properties to further refine export/import behavior. These are defined in an optional <strong>properties</strong> element, as in the following example:</p>
<pre>{
  "name":"Default Production Promotion",
  "description":"Dev to production default profile",
  "targetEnvironment":"production",
  "properties":[
    {
      "name":"export-pki",
      "value":"true"
    }
  ]
}</pre>
<p>You can set the following properties on a PromotionProfile:</p>
<ul>
	<li><strong>export-pki</strong>
<p>This option indicates that the PKI keys and certificate for an API will be included in the promotion if they exist. Note that if the target environment for a promotion is on a different container from the source environment, the API's certificate or an ancestor in the chain must be trusted by the target container's certificate authority, or it will be ignored when importing the API.</p>
<p>A value of <strong>true</strong> indicates that PKI keys and certificate should be promoted. The default value for this property is <strong>false</strong>.</p></li>
	<li><strong>match-policies-by-name</strong>
<p>Setting this property to a value of <strong>true</strong> indicates that custom policies in the source and target environments are to be implicitly mapped by policy name (regardless of their unique keys).</p>
<p>For example, without this property present, an API referencing a policy named <strong>MyCustomAuditingPolicy</strong> in the source environment will fail validation even if there is a policy with the same name in the target environment, unless there is a policy mapping explicitly defined between the policies. With the property set to <strong>true</strong>, the API will pass validation and will be assigned the policy with the same name in the target environment.</p>
	</li>
</ul>


<h3 id="dz_configurations">Deployment Zone Configurations</h3>
<h5 class="stamp">API Platform Version: 8.4.12 and later</h5>
<p>Within a promotion profile, deployment zone configurations can be used to tailor the propagation of an API's endpoints to the target environment. During API promotion, applicable deployment zone configurations are selected based on:</p>
<ul>
	<li>The name of an API endpoint's deployment zone in the source environment.</li>
	<li>Optionally, filters that apply to the metadata of the API.</li>
</ul>
<p>A deployment zone configuration contains a list of deployment zone names in the target environment. When a deployment zone configuration is determined to be applicable for an endpoint of the API being promoted, the endpoint is populated into the specified target environment deployment zones.</p>
<p><strong>Note</strong>: The target deployment zone must have a listener that matches the listener name of the endpoint. If necessary, use rules in the deployment zone configuration to adjust listener names.</p>
<p>The structure of the deployment zone configurations allows endpoints in a source environment to be fanned out to a target environment. For example, a staging environment might only support a single deployment zone while the production environment supports many deployment zones across different geographic regions.</p>
<p>Consider the following example PromotionProfile:</p>
<pre>{
  "name":"Default Production Promotion",
  "targetEnvironment":"production",
  "deploymentZoneConfigurations":[
    {
      "sourceDeploymentZoneName":"StagingDZ",
      "targetDeploymentZoneNames":[
        "ProdWestDZ",
        "ProdEastDZ"
      ]
    }
  ]
}</pre>
<p>In this example, a single deployment zone configuration has been defined to propagate endpoints in in the <strong>StagingDZ1</strong> deployment zone in the source environment to both <strong>ProdWestDZ</strong> and <strong>ProdEastDZ</strong> in the target environment.</p>


<h4 id="s06_01">Using Filters with deployment zone configurations
</h4><p>The filtering capability of deployment zone configurations allows for target deployment zones to be determined based on the metadata of the API. For example, security metadata associated with the API might determine the specific deployment zones that the API is deployed to.</p>
<p>In the following example, the filters named <strong>PII</strong> and <strong>Not PII</strong> are used in selecting the deployment zones an API's endpoints are propagated to in the target environment, based on whether the API is marked as processing personal identity information.</p>
<pre>"deploymentZoneConfigurations": [
  {
    "filterNames": [
      "pii"
    ],
    "sourceDeploymentZoneName": "StagingDZ",
    "targetDeploymentZoneNames": [
      "PIIDZ"
    ]
  },
  {
    "filterNames": [
      "not-pii"
    ],
    "sourceDeploymentZoneName": "StagingDZ",
    "targetDeploymentZoneNames": [
      "NotPIIDZ"
    ]
  }
]</pre>


<p>For the above example, the filters in the topology are defined as shown below.</p>
<pre>"filters": [
  {
    "name": "pii",
    "classifier-criteria": [
      {
        "classifierName": "pii",
        "values": [
          {
            "value": "true"
          }
        ]
      }
    ]
  },
  {
    "name": "not-pii",
    "classifier-criteria": [
      {
        "classifierName": "pii",
        "values": [
          {
            "value": "false"
          }
        ]
      }
    ]
  }
]
</pre>


<h4 id="s06_02">Default Endpoint Propagation</h4>
<p>If an endpoint's source deployment zone doesn't match a defined deployment zone configuration, the promotion processing will propagate the endpoint to a deployment zone in the target environment with the same name, if one exists. You can think of this as an implicit deployment zone configuration for every deployment zone in the source environment of the form:</p>
<pre>{
  "sourceDeploymentZoneName":"{source DeploymentZone name}",
  "targetDeploymentZoneNames":[
    "{source DeploymentZone name}"
  ]
}</pre>

<p>You can disable endpoints from a source deployment zone completely by defining a deployment zone configuration that specifies no target deployment zone names. For example:</p>
<pre>{
  "sourceDeploymentZoneName":"TestDZ",
  "targetDeploymentZoneNames":[

  ]
}</pre>



<h4 id="s06_03">Using Rules with deployment zone configurations
</h4><p>A deployment zone configuration can optionally contain RuleDefinitions to be applied to the properties of the endpoints being promoted with this deployment zone configuration.</p>
<p>At this level, you can use rules to alter a listener name, the endpoint's path, or its vanity host. The properties available for modification are:</p>
<dl>
	<dt>listenerName</dt>
	<dd>The name of the endpoint's listener; for example, <strong>http</strong>. It must match a listener associated with the target deployment zone.</dd>

	<dt>path</dt>
	<dd>The endpoint-specific path. If the endpoint in the source environment did not have an endpoint-specific path, this will be set to <strong>NO_VALUE</strong>. A rule can set the path property to another value, or to <strong>NO_VALUE</strong> indicating that the target endpoint will not have a specific path.</dd>

	<dt>vanityHostName</dt>
	<dd>A host name (CNAME) specific to the endpoint. If the endpoint in the source environment did not have a vanity host name, this will be set to <strong>NO_VALUE</strong>. A rule can set the vanityHostName property to another value, or to <strong>NO_VALUE</strong> which indicates that the target endpoint will not have a vanity host name.</dd>

	<dt>DISABLED</dt>
	<dd>This property provides a means of disabling an endpoint via a rule. If you set the value of DISABLED to <strong>true</strong>, the endpoint is not propagated to the target environment.</dd>
</dl>

<p>In the example shown below, a rule is provided with a deployment zone configuration that will disable the propagation of endpoints that do not have a vanity host name in the source environment.</p>
<pre>{
  "sourceDeploymentZoneName":"StagingDZ",
  "targetDeploymentZoneNames":[
    "ProdDZ"
  ],
  "rules":[
    {
      "scope":"vsep",
      "condition":"vsep.vanityHostName == 'NO_VALUE'",
      "action":"vsep.DISABLED = 'true'"
    }
  ]
}</pre>


<h4 id="s06_04">Duplicate Endpoints</h4>
<p>Care should be taken to avoid duplicating endpoints across environments using the same underlying Gateways. This situation can occur if the target deployment zone has the same underlying Gateway as the source deployment zone (leading to the same host name and port) and has no options set for altering the Gateway host name or path. This situation will result in the promotion of the API failing.</p>
<p>There are several ways you can help make sure there are no duplicate endpoints:</p>
<ul>
	<li>Enable random prefixes in the target deployment zone.</li>
	<li>Provide a custom hostname for the Gateway in the target deployment zone that differs from the source deployment zone.</li>
	<li>Use a rule in the deployment zone configuration to alter the vanity host name or path of the endpoints being promoted.</li>
</ul>
<p><a href="#top">Back to top</a></p>










<h3 id="s08_03_environment_config">Environment Configuration</h3>
<p>The <strong>configuration</strong> property of an Environment is used to customize behavior of assets, such as APIs, that are created or updated in the tenant that the environment is associated with. You can use an environment's configuration to define <strong>templating</strong> aspects of API implementations. This is similar to the behavior described in the section <a href="#runtime_config">Defaulting API Settings using Runtime Configurations</a>. This is because the environment configuration automates the creation of Runtime Configuration assets in the tenant library. Further information on the defaulting behavior described here can be found in that section.</p>
<p>The following is a complete example of an <strong>Environment Configuration</strong> definition.</p>
<pre>{
  "name": "development",
  "displayName": "Development",
  "description": "Development environment",
  "tenant": "DevelopmentTenant",
  "configuration": {
    "apiImplementationProfiles": [
      {
        "name": "Internal API Profile",
        "type": "Live",
        "filterNames": [
          "internal"
        ],
        "deploymentZones": [
          "DZ9941"
        ],
        "virtualServicePolicies": [
          {
            "policyName": "DetailedAuditing"
          }
        ],
        "virtualHost": "InternalHost.com",
        "path": "/{catalog_asset.name_normalized}",
        "allowAnonymousAccess": "true"
      },
      {
        "name": "External API Profile",
        "type": "Live",
        "filterNames": [
          "external"
        ],
        "deploymentZones": [
          "DZ9942"
        ],
        "virtualHost": "ExternalHost.com",
        "path": "/{catalog_asset.name_normalized}/external",
        "allowAnonymousAccess": "false",
        "approvalRequired": "true"
      }
    ]
  }
}</pre>


<h4 id="s08_04_api_impl_profiles">API Implementation Profiles </h4>
<p>A Configuration contains an <strong>apiImplementationProfiles</strong> collection. An <strong>apiImplementationProfile</strong> is used to define the defaults for all API Implementations in the tenant that match the type and filter of the apiImplementationProfile. In the example above, the apiImplementationProfile <strong>Internal API Profile</strong> will apply to the <strong>Live</strong> implementations of APIs whose custom properties match the <strong>internal</strong> filter (defined in the <strong>filters</strong> property of the topology), while the <strong>External API Profile</strong> will apply to <strong>Live</strong> implementations of APIs that match the <strong>external</strong> filter. Note that the two options for the <strong>type</strong> property are <strong>Live</strong> and <strong>Sandbox</strong>.</p>
<p>An <strong>apiImplementationProfile</strong> collection can specify:</p>
<ul>
	<li>The Deployment Zones that an API Implementation is to be deployed to:
		<p>Specify the deployment zone names in the <strong>deploymentZones</strong> property (for additional details, see <a href="#dz_config">Deployment Zone Configuration</a> {following section}).</p></li>
	<li>The policies that are to be applied to the Implementation:
		<p>Specify either the <strong>policyName</strong> or <strong>policyId</strong> for each policy to be applied.</p></li>
	<li>The policies that are to be applied to the physical service of a proxy Implementation (not shown in example above):
		<p>Specify either the <strong>policyName</strong> or <strong>policyId</strong> for each policy to be applied within a <strong>physicalServicePolicies</strong> property.</p></li>
	<li>The virtual host for the implementation's endpoints:
		<p>Specify using the <strong>virtualHost</strong> property.</p></li>
	<li>The path for the implementation's endpoints:
		<p>Specify using the <strong>path</strong> property.</p></li>
	<li>Whether the API implementation allows anonymous access:
		<p>Specify in the Boolean <strong>allowAnonymousAccess</strong> property.</p></li>
	<li>Whether access to the API implementation requires approval:
		<p>Specify in the Boolean <strong>requiresApproval</strong> property.</p></li>
	<li>Whether debug mode should be enabled for the API implementation (not shown in example above):
		<p>Specify in the Boolean <strong>debugModeEnabled</strong> property.</p></li>
</ul>
<p><a href="#top">Back to top</a></p>



<p>{<span class="apidoc_red">TG new piece below. Not sure whether it should be same importance as xxx or a lower heading level? Please review. Thx!</span>}</p>


<h5 id="dz_config">Deployment Zone Configuration</h5>
<p>The <strong>deploymentZones</strong> property of an <strong>apiImplementationProfile</strong> is used to specify which deployment zones and optionally which listeners within a deployment zone and API should support an API's endpoints. In the simplest case, a deployment zone can be specified with no additional details, as in this example:</p>
<pre>{
  "name" : "DZ9941"
}</pre>
<p>In this example, APIs that are using this apiImplementationProfile will be deployed to all listeners within the designated deployment zone.</p>
<p>The following example goes a step further and specifies a specific listener within the deployment zone that should be used:</p>
<pre>{
  "name": "DZ9941",
  "listeners": [
    {
      "name": "default-http0"
    }
  ]
}</pre>
<p>Additionally, listener-specific settings can be defined as in this example:</p>
<pre>{
  "name": "DZWest",
  "listeners": [
    {
      "name": "default-http",
      "public": "false",
      "virtualHost": "listenerscopedhost",
      "path": "listenerscopedpath"
    },
    {
      "name": "default-https",
      "useImplementationKeyforSSL": "true"
    }
  ]
}</pre>
<p>In this case, two listeners were specified within the DZWest deployment zone. Endpoints deployed in the <strong>default-http</strong> listener will:</p>
<ul>
	<li>Be set to private.</li>
	<li>Use a listener-specific host name (which overrides the <strong>virtualHost</strong> property set in the <strong>apiImplementationProfile</strong>).</li>
	<li>Use a listener-specific path (which overrides the <strong>path</strong> property set in the <strong>apiImplementationProfile</strong>).</li>
</ul>
<p>Endpoints deployed in the <strong>default-https</strong> listener are set to use the API Implementation's Key/Certificate for SSL, but will be public by default and will use the <strong>virtualHost</strong> and <strong>path</strong> of the containing <strong>apiImplementationProfile</strong> (if <strong>virtualHost</strong> and <strong>path</strong> are specified).</p>

<h5 id="replacement_parms">Replacement Parameters</h5>
<p>A limited number of replacement parameters are available for use in setting the <strong>virtualHost</strong> and <strong>path</strong> properties at the apiImplementationProfile and listener level of an Environment configuration. To use these parameters, specify the parameter name within braces <strong>{&lt;parameter&gt;}</strong> within either the <strong>virtualHost</strong> or <strong>path</strong> properties. For example:</p>
<pre>"path" : "{api.name_normalized}_{api.version_normalized}"</pre>
<p>At runtime, the platform replaces these parameters with information from the API. In the above example, an API with name <strong>CurrencyConverter</strong> and version <strong>1</strong> would result in a path of <strong>currencyconverter_1</strong>.</p>
<p>The following replacement parameters are currently available:</p>
<ul>
	<li><strong>api.name</strong>
<p>The actual name of the API.</p></li>
	<li><strong>api.version</strong>
<p>The actual version of the API.</p></li>
	<li><strong>api.name.normalized</strong>
<p>The api nam,e normalized for use as an NM token.</p></li>
	<li><strong>api.version.normalized</strong>
<p>The api version, normalized for use as an NM token.</p></li>
	<li><strong>api.physical_url_path.live</strong>
<p>The path of the first physical endpoint for the live implementation of the API. This is only applicable when the API implementation is using the proxy pattern.</p></li>
	<li><strong>api.physical_url_path.sandbox</strong>
<p>The path of the first physical endpoint for the sandbox implementation of the API. This is only applicable when the API implementation is using the proxy pattern.</p></li>
	<li><strong>api.property</strong>
<p>The value of the specified custom API property. For example, if an API has the property <strong>classification</strong> set to <strong>restricted</strong>, the parameter <strong>{api.property.classification}</strong> will resolve to <strong>restricted</strong>.</p></li>
</ul>
<p><strong>Note</strong>: A parameter that cannot be resolved or is not recognized will remain in the unresolved form.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="topology_api">Topology API</h3>
<p>In this section:</p>
<ul>
	<li>Finding the Topology API Documentation</li>
	<li>Using the Topology API</li>
</ul>


<h4 id="topologyapi_01">Finding the Topology API Documentation</h4>
<p>You can find the Topology API documentation in the following locations:</p>
<ul>
	<li>In your deployment:
		<ul>
			<li>Once the Lifecycle Coordinator feature is deployed, a REST API for maintaining topologies is available from the path <strong>/lc/api/topologies</strong> relative to the container's URL. For example:
			<p><strong>http://myHost:9900/lc/api/topologies</strong></p></li>
			<li>You can find Swagger documentation for this API in the container deployment:
			<p><strong>$INSTALL_DIR/docs/restApiDocs/api-platform/swagger-Topology_API.html</strong></p></li>
		</ul>
	</li>
	<li>On the <a href="../../ag/assets/restApiDocs_api-platform_84/api-urn_com.akana.lifecyclecoordinator.rest-TopologyAPI.html" title="Topology API on Akana docs site">Akana docs site</a>.</li>
</ul>


<h4 id="topologyapi_02">Using the Topology API</h4>
<p>The first step is to create a Topology. This is done by POST-ing the complete Topology JSON document to <strong>...lc/api/topologies</strong>. This can be done programmatically or with a browser plugin such as Firefox RESTClient:</p>
<p><img src="images/promotion_10.jpg" alt="Creating the topology" /></p>
<p>Note the inclusion of the content-type and basicAuth headers.</p>
<p>Updates to the topology can be performed on the topology as a whole, or on specific properties within the document. For example, the Rules for a PromotionProfile can be updated with a PUT of an array of Rules such as:</p>
<pre>[
  {
    "scope":"psep",
    "condition":"psep.url.indexOf(\"foo.com\") > 0",
    "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
  }
]</pre>
<p>To:</p>
<pre>http://myHost:9900/lc/api/topologies/{topology-name}/environments/{environment-name}/profiles/{promotionProfile-name}/rules</pre>
<p><a href="#top">Back to top</a></p>



<h3 id="lm_console">Lifecycle Manager Console</h3>
<p>The Lifecycle Manager (<strong>LM</strong>) console is useful for accessing promoted assets and their iterations as well as approving promotion requests. Within Lifecycle Manager, a topology is represented as a <strong>library</strong> and the elements of a Topology along with the entities being promoted are represented as <strong>assets</strong>.</p>


<h4 id="s07_01">Logging In</h4>
<p>The first step is to log in to the library that corresponds with the topology. There are two options:</p>
<ul>
	<li>If the admin user password has been set, you can log into the library as the Lifecycle Repository super user at the URL below:
		<pre>{container-base-url}/lm/application/access/suLogin.do</pre></li>
	<li>If the topology was configured to delegate authentication to a local tenant, you can log in at the URL below, using the tenant email and password for a user in the designated local tenant:
	<pre>{container-base-url}/lm/application/access/challenge.do</pre></li>
</ul>


<h4 id="s07_02">Viewing Assets and Iterations</h4>
<p>The left pane of the LM console contains a search box which can be used for finding assets by name:</p>
<p><img src="images/promotion_11.jpg" alt="Finding assets by name" /></p>
<p>The search results include separate LM assets for each environment to which a promotable entity has been promoted or is pending promotion. Clicking on an asset in the search results brings up a details page:</p>
<p><img src="images/promotion_12.jpg" alt="Published asset, Details page" /></p>
<p>In this case, the <strong>Current Iteration</strong> relationship is referencing the third iteration of this API asset. Click on the iteration asset name to view details about the iteration, as shown below.</p>
<p><img src="images/promotion_13.jpg" alt="Iteration details" /></p>
<p>Here you can see the following details for this iteration:</p>
<ul>
	<li>The time the iteration was promoted</li>
	<li>The user who requested the promotion</li>
	<li>The status of the promotion</li>
	<li>The actual archive.zip (after rule processing) that was imported into the target environment</li>
	<li>The response from the Import</li>
	<li>A relationship to the previous iteration for this environment</li>
	<li>A relationship to the source iteration in the previous environment</li>
	<li>A relationship to the PromotionProfile that was used to promote the iteration</li>
</ul>
<p>Additionally, in the case of a promotion failure (generally due to an invalid rule) error details are stored in the Artifacts section of the iteration asset:</p>
<p><img src="images/promotion_14.jpg" alt="Error details" /></p>

<h4 id="s07_03">Promotion Requests</h4>
<p>The configuration of the topology library can optionally be customized to require approvals for a promotion request. For assistance with customization, contact Akana Professional Services.</p>
<p>In this scenario, a user with the required authorization role has a pending request notification message in the left pane after logging into the LM console:</p>
<p><img src="images/promotion_15.jpg" alt="Pending requests" /></p>
<p>Clicking on the details for that request allows the user to approve the request:</p>
<p><img src="images/promotion_16.jpg" alt="Approving a pending request" /></p>
<p>Clicking <strong>approve</strong> allows the promotion to succeed or proceed to the next role approval.</p>
<h5>Rejecting Requests</h5>
<p>A user may choose to reject the request by clicking on <strong>rejection properties</strong> and then clicking <strong>reject</strong>. In this case, the Iteration asset remains in a <strong>Promotion Pending</strong> state, however, the API Platform UI shows the state of the promotion as <strong>Promotion Rejected</strong> and allows the promotion to be requested again.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="env_decoupled_00">Support for Decoupled Environments in a Topology</h3>
<p>In a standard topology, Lifecycle Coordinator communicates directly with the environments in the topology to:</p>
<ul>
	<li>Periodically retrieve context information for the environment (read).</li>
	<li>Import a promoted asset to the environment (write).</li>
</ul>
<p>However, in some situations, an environment (generally a production environment) might be physically isolated from Lifecycle Coordinator and other internal systems for security purposes.</p>
<p>Lifecycle Coordinator supports this scenario by allowing tenants to be designated as not connected. This is done using the <strong>connected</strong> property, as in this example tenant definition:</p>
<pre>{
  "name": "ProductionTenant",
  "id": "prod",
  "connected" : "false"
}</pre>
<p>In the case where a tenant is marked as not connected, only the tenant's name and id must be specified. Credentials and address are omitted, since Lifecycle Coordinator does not communicate with that tenant.</p>
<p>When a tenant is marked as not connected, Lifecycle Coordinator assumes that it is on a remote system and that the <strong>preserve-keys</strong> mode is applicable.</p>
<p>Normally, a tenant that is not connected is the final environment in the promotion path.</p>
<p>Because Lifecycle Coordinator cannot communicate directly with a tenant that is not connected, some external system or user must facilitate the exchange of data between Lifecycle Coordinator and the decoupled tenant. The two scenarios are:</p>
<ul>
	<li><a href="#env_decoupled_01">Updating Environment Context information</a></li>
	<li><a href="#env_decoupled_02">Promoting Assets</a></li>
</ul>
<h4 id="env_decoupled_01">Updating Environment Context information</h4>
<p>Lifecycle Coordinator needs to have some understanding of the target environment supported by a decoupled tenant so that it can validate for the existence of dependencies when an asset is promoted to that environment. To accomplish this, the promotion context information must be fetched from the decoupled tenant with a GET call to the <strong>getEnvironmentPromotionContext</strong> operation of the TenantAdministrationAPI on the isolated system.</p>
<pre>{host:port}/api/tenants/{tenant id}/{environment name}/promotion/context?includeServiceInfo=true&amp;includeAPIInfo=true</pre>
<p>Content-type is application/json.</p>
<p>For example:</p>
<pre>GET http://tenant3:9940/api/tenants/tenant3/production/promotion/context?includeServiceInfo=true&amp;includeAPIInfo=true</pre>
<p>The resulting JSON document can then be passed as the request body to the TopologyAPI <span class="apidoc_code"><strong>updateEnvironmentContext</strong></span> method on the Lifecycle Coordinator system using a PUT call to:</p>
<pre>{host:port}/lc/api/topologies/Topology1/environments/{environment name}/context</pre>
<p>For example:</p>
<pre>PUT http://localhost:9920/lc/api/topologies/Topology1/environments/production/context</pre>
<p>This process should be repeated when any relevant context information in the decoupled environment changes. For example, a new policy or organization is added in the decoupled tenant.</p>


<h4 id="env_decoupled_02">Promoting Assets</h4>
<p>Since Lifecycle Coordinator cannot directly call the import API on the decoupled tenant, you'll need to take some extra steps to promote to that environment.</p>

<h5>To promote assets for a decoupled tenant</h5>
<ol>
	<li>Request promotion of the API to the decoupled environment in the normal way, using the API Platform user interface or via the TopologyAPI promote operation (see <a href="http://docs.akana.com/ag/assets/restApiDocs_api-platform_84/api-urn_com.akana.lifecyclecoordinator.rest-TopologyAPI.html" title="Link to generated Topology API doc" target="_blank">Topology API</a>).
<p>When the promotion is complete, the status of the asset for the decoupled environment shows as <strong>promoted</strong>. In this case, the <strong>promoted</strong> status indicates that all processing of the archive has been completed and the archive is ready for importing into the target environment.</p></li>
	<li>Use the <strong>getPackage</strong> method in the TopologyAPI to retrieve the processed import package from Lifecycle Coordinator:
		<pre>GET {host:port}/lc/api/topologies/{topology-name}/environments/{environment-name}/assets/{asset-id}/package</pre>
		<p>In this operation, {asset-id} is either an API version ID or App version ID. For example:</p>
		<pre>GET http://localhost:9920/lc/api/topologies/Topology1/environments/production/assets/ffc4ba19-c5cb-4e9d-ae39-78ab6e0efc84.tenant1/package</pre>
		<p>This returns the archive as a ZIP file.</p></li>
	<li>On the isolated system, upload the archive ZIP file to the decoupled tenant in one of these ways:
		<ul>
			<li>Via the import wizard in the API Platform UI: see <a href="../learnmore/bus_admin_export_import.htm#import_org_app_api">How do I import site, app, or API information from an export file?</a></li>
			<li>By using the importPackage operation on the TenantAdministrationAPI: see <a href="../api/tenantadmin/m_tenantadmin_importPackage.htm"><span class="apidoc_code">POST /api/tenants/{TenantFedMemberID}/packages</span></a>.</li>
		</ul>
	</li>
</ol>
<p><a href="#top">Back to top</a></p>



<h3 id="runtime_config">Defaulting API Settings using Runtime Configurations</h3>
<h5 class="stamp">API Platform Version: 8.4.17 and later</h5>
<p><strong>Note</strong>: As of the 2018.0.0 release, the behavior in this section can now be defined within the topology directly, using the <strong>Environment Configuration</strong> element. See <a href="#s08_03_environment_config">Environment Configuration</a>.</p>
<p>The behavior described in this section is not part of Lifecycle Coordinator, but can be used to augment the capabilities of Lifecycle Coordinator to further tailor the configuration of APIs within each environment of a topology.</p>
<p>The intent of the Runtime Configurations feature is to allow <strong>templates</strong> for API implementation properties to be established and selectively applied based on custom property filters. This is accomplished through customization of the Lifecycle Manager library in which custom properties for a tenant are configured. This configuration requires a working knowledge of the Lifecycle Manager application and the Configuration Designer Tool.</p>
<p>As with the topology definition, it's best if Runtime Configuration assets are set up during the initial configuration of the environment. Changes to a Runtime Configuration do not retroactively affect pre-existing APIs unless those APIs are updated through the API Platform UI or subsequent promotions.</p>


<h4 id="s08_01_create_asset">Creating a Runtime Configuration Asset</h4>
<p>You can use the Lifecycle Manager user interface to create assets of type <strong>Runtime Configuration</strong>. The following image shows the Lifecycle Manager edit page for a Runtime Configuration asset:</p>
<p><img src="images/promotion_17_runtime_config_asset.jpg" alt="Creating a Runtime Configuration asset" /></p>
<p>The following aspects of a Runtime Configuration asset determine its behavior when applied to an API implementation:</p>
<ul>
	<li><a href="#s08_01_01_owning_group">Owning Group</a></li>
	<li><a href="#s08_01_02_asset_filters">Asset Filters</a></li>
	<li><a href="#s08_01_03_implementation_type">Implementation Type</a></li>
	<li><a href="#s08_01_04_policies">Policies</a></li>
	<li><a href="#s08_01_05_virtual_host">Virtual Host</a></li>
	<li><a href="#s08_01_06_path">Path</a></li>
	<li><a href="#s08_01_06b_dzs">Deployment Zones</a></li>
	<li><a href="#xxx">xxx</a></li>
	<li><a href="#s08_01_07_anon_access">Allow Anonymous Access</a></li>
	<li><a href="#s08_01_08_approval_req">Approval Required</a></li>
	<li><a href="#s08_01_09_debug_mode">Debug Mode Enabled</a></li>
</ul>


<h5 id="s08_01_01_owning_group">Owning Group</h5>
<p>Groups within the Lifecycle Manager library reflect the Organizations of the associated tenant. The <strong>Owning Group</strong> chosen when creating a Runtime Configuration asset determines the organizational scope that the Runtime Configuration applies to.</p>
<p>For example, if the tenant organization has two child organizations <strong>A</strong> and <strong>B</strong>, a Runtime Configuration asset assigned to Group <strong>A</strong> is applicable to APIs in organization <strong>A</strong> but not to APIs in organization <strong>B</strong>. If you choose the tenant organization as the owning group, the Runtime Configuration is applicable to all APIs within the tenant.</p>

<h5 id="s08_01_02_asset_filters">Asset Filters</h5>
<p>You can further scope the applicability of Runtime Configuration assets by using <strong>asset filters</strong>. Asset filters are defined in the Library Process Configuration document (LPC) for the library, and specify criteria for the custom properties of the API (known as <strong>classifiers</strong> within Lifecycle Manager). For example, the filter below selects APIs with the <strong>PII</strong> custom property set to <strong>true</strong>:</p>
<pre>&lt;asset-filter name="PII APIs"&gt;
  &lt;classifier-criteria classifier-category="asset-type"&gt;
    &lt;value-set&gt;
      &lt;value&gt;API&lt;/value&gt;
    &lt;/value-set&gt;
  &lt;/classifier-criteria&gt;
  &lt;classifier-criteria classifier-category="pii"&gt;
    &lt;value-set&gt;
      &lt;value&gt;<strong>true</strong>&lt;/value&gt;
    &lt;/value-set&gt;
  &lt;/classifier-criteria&gt;
&lt;/asset-filter&gt;
</pre>
<p>When selecting a value for the Asset Filter classifier, a list of asset filters defined in the LPC as well as implicit filters for the defined asset types in the library will be shown. The filter in the example above would appear as <strong>LPC:PII APIs</strong>. Selecting the implicit filter <strong>asset-type:API</strong> indicates that the Runtime Configuration is applicable to all APIs within its owning group.</p>
<p>Note that any filter chosen for a Runtime Configuration should include criteria specifying <strong>API</strong> as the asset-type.</p>

<h5 id="s08_01_03_implementation_type">Implementation Type</h5>
<p>This classifier specifies the type of API implementation the Runtime Configuration applies to. The choices are <strong>Live</strong> and <strong>Sandbox</strong>.</p>

<h5 id="s08_01_04_policies">Policies</h5>
<p>A Runtime Configuration asset provides three classifiers that you can use to select policies to be applied to applicable API implementations. These classifiers are:</p>
<ul>
	<li>Operational Policy</li>
	<li>Compliance Policy</li>
	<li>Service Level Policy</li>
</ul>
<p>When choosing values for these classifiers, the application will present a list of policies available for the associated tenant with the specified policy type. You can choose one or more policies for each classifier.</p>
<p>Additionally, there are three classifiers that allow you to select policies for the physical service supporting an API implementation using the <strong>proxy</strong> pattern. These classifiers are: </p>
<ul>
	<li>Operational Policy (Physical Service)</li>
	<li>Compliance Policy (Physical Service)</li>
	<li>Service Level Policy (Physical Service)</li>
</ul>

<p id="policy_replacement"><strong>Policy Replacement Behavior</strong></p>
<p>The default behavior for setting policies on an API implementation or physical service is additive, meaning that policies specified in the Runtime Configuration are added to any existing policies on the implementation or physical service. However, you can customize the default behavior to control policy replacement behavior.</p>
<p>Here are a couple of examples of how this could be used:</p>
<ul>
	<li><strong>Adding a policy</strong>: Let's say there is a two-environment topology, <strong>dev</strong> and <strong>prod</strong>, and the topology is configured so that policies from dev are preserved when promoting, but you also want to make sure that the production-level security policy is in place for all APIs that are PCI-compliant. You could set up a Runtime Configuration with a <strong>pci = true</strong> filter that specifies the production-level security policy, but you probably wouldn't want to remove other policies the API may have. In this scenario, you could set the <strong>preserve-existing-policies</strong> property to <strong>true</strong>. The new policy is in addition to any existing policies.</li>
	<li> <strong>Replacing existing policies</strong>: Let's say you want to completely automate the assignment of policies to APIs, managing it entirely based on properties set on the API. In this case, you could set the <strong>preserve-existing-policies</strong> property to <strong>false</strong>. The Runtime Configuration would then overwrite any policies that were manually set or were in the promotion from an earlier environment. The policies in the Runtime Configuration would replace all existing policies.</li>
</ul>
<p>There are two ways that you can customize policy replacement behavior:</p>
<ul>
	<li><a href="#policy_replacement_pre_2018">By setting the <strong>preserve-existing-policies</strong> property</a></li>
	<li><a href="#policy_replacement_2018">By setting the <strong>ENV:preserve-existing-policies</strong> property in the repository library</a> (2018.0.0 and later)</li>
</ul>
<p>In any case, if a policy classifier has no value in the Runtime Configuration, no action will be taken with the policies associated with the implementation or physical service.</p>

<p id="policy_replacement_pre_2018"><strong>Setting the <strong>preserve-existing-policies</strong> property</strong></p>
<p>You can customize the <strong>Apply Runtime Configuration</strong> API post-processing task using the Configuration Designer by setting the <strong>preserve-existing-policies</strong> property to <strong>false</strong>. This indicates that any existing policies on the implementation or physical service that are not specified in the Runtime Configuration will be removed, and replaced by those in the Runtime Configuration.</p>
<p>When the <strong>preserve-existing-policies</strong> property is set to <strong>false</strong>, you can specify the value of <strong>NONE</strong> for any of the policy classifiers. This indicates that all policies should be removed from the implementation or physical service.</p>
<p>In the example below, the <strong>preserve-existing-policies</strong> property is set to <strong>false</strong> in an environment configuration of a topology.</p>
<pre>"configuration": {
  "properties" : [
    {"name":"preserve-existing-policies","value":"false"}
  ],
  "apiImplementationProfiles": [ 
  ...
  ]
}</pre>
<p id="policy_replacement_2018"><strong>Setting the ENV:preserve-existing-policies property in the repository library</strong> (2018.0.0 and later)</p>
<p>In the example below, the <strong>ENV:preserve-existing-policies</strong> library property is set directly in the LPC document of the repository library.</p>
<pre>&lt;library-properties&gt;
  &lt;property name=&quot;ENV:preserve-existing-policies&quot;&gt;
    &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;/library-properties&gt;</pre>

<h5 id="s08_01_05_virtual_host">Virtual Host</h5>
<p>This classifier is used to set the vanity host name for every endpoint in the implementation. Leaving this classifier unset indicates that the host name of the endpoints should not be modified.</p>

<h5 id="s08_01_06_path">Path</h5>
<p>This classifier is used to set the context path for every endpoint in the implementation. Leaving this classifier unset indicates that the context path of the endpoints should not be modified.</p>


<p><strong>Parameter Replacement</strong></p>
<p>The <strong>path</strong> classifier supports the Lifecycle Manager concept of <strong>context parameters</strong>. This allows aspects of the API such as the API name or values of custom properties to be used within the path.</p>
<p>For example, setting the path value to <strong>/{catalog_asset.name_normalized}</strong> indicates that the path should consist of the API's name. If an API had a custom classifier called <strong>visibility</strong> set to a value <strong>external</strong>, using a value of <strong>/rest/{catalog_asset.classifier.visibility}</strong> for the path would result in endpoint paths set to <strong>/rest/external</strong>.</p>
<p>The available parameters are specified in the Lifecycle Manager Configuration guide (available on the Akana Library site, in the Documentation folder for your <a href="https://library.roguewave.com/display/MAIN/Lifecycle+Manager" title="Link to Lifecycle Manager download" target="_blank">Lifecycle Manager installation</a>). Note that the context asset for parameter resolution is the API asset.</p>


<h5 id="s08_01_06b_dzs">Deployment Zones</h5>
<h5 class="stamp">API Platform Version: 8.4.18 and later</h5>
<p>A Runtime Configuration asset can include a Deployment Zones classifier. This allows deployment zones to be designated for deployment of API implementations that match the filter of the Runtime Configuration asset.</p>
<p>When the Deployment Zones classifier is edited, a list of Deployment Zones defined in the associated tenant is displayed. Any number of these deployment zones can be selected. Then, matching API implementations are deployed in the selected deployment zones.</p>
<p>If the Deployment Zones classifier is left empty, the deployment zones of a matching API implementation will not be affected.	However, setting the classifier to a value of <strong>NONE</strong> will result in matching API implementations having no deployment zones enabled.</p>
<p> Settings designated in the <strong>Path</strong> and <strong>Virtual Host</strong> classifiers are applied to the endpoints in the designated deployment zones.</p>


<p>--------------------------begin new section--------------------------</p>
<h5 id="xxx">xxx</h5>
<p>{<span class="apidoc_red">TG not sure if this is a separate section or an add-on to the previous section?</span>}</p>
<p>{<span class="apidoc_red">TG: for this one, JIRA says API Platform Version: 8.4.18 and later  but doc says API Platform Version: 2018.0.0 and later</span>}</p>
<p>While the Deployment Zones classifier mentioned above can specify deployment zones for an API to be deployed to, it is sometimes necessary to also specify listeners within a deployment zone as well as specific settings for each listener. If this level of granularity is needed, the Deployment Zones classifier should be left unset and instead the <strong>Deployment Zone Configuration</strong> artifact in the Runtime Configuration asset should be used. This artifact should be a JSON document containing a JSON array of deploymentZone properties in the same format as shown for the deploymentZones property of an Environment Configuration (link to Environment Configuration section). Here is a sample Deployment Zones Configuration document:</p>
<pre>[
  {
    "name": "DZ9921"
  },
  {
    "name": "DZ9941",
    "listeners": [
      {
        "name": "default-http0",
        "public": "false",
        "virtualHost": "{api.property.internal}",
        "path": "{api.name_normalized}_{api.version_normalized}"
      },
      {
        "name": "default-https",
        "useImplementationKeyforSSL": "true"
      }
    ]
  }
]</pre>
<p>Note that only the deployment zone name is required in each <strong>deploymentZone</strong> property. Also be aware that there is no configuration-time validation of the information specified in the Deployment Zones Configuration document, so care must be taken to ensure that it is in sync with the actual deployment zones and listeners defined in the API platform instance.</p>
<p>--------------------------end new section--------------------------</p>







<p><strong>Deployment Zone Replacement Behavior</strong></p>
<p>By default, the deployment zones specified on the Runtime Configuration asset replace those already enabled for a matching API implementation.</p>
<p>Using Configuration Designer, it is possible to customize the <strong>Apply Runtime Configuration API</strong> post-processing task by setting the <strong>Preserve Existing Deployment Zones</strong> property <strong>to</strong> true. This indicates that any existing deployment zones enabled for a matching API implementation will be merged with those specified on the Runtime Configuration asset.</p>


<h5 id="s08_01_07_anon_access">Allow Anonymous Access</h5>
<p>This classifier is used to set the <strong>allow anonymous access</strong> value of the implementation. Leaving this classifier unset indicates that the <strong>allow anonymous access</strong> value of the implementation should not be modified.</p>

<h5 id="s08_01_08_approval_req">Approval Required</h5>
<p>This classifier is used to set the <strong>approval required</strong> value of the implementation. It is only applicable when <strong>allow anonymous access</strong> is set to <strong>false</strong>. Leaving this classifier unset indicates that the <strong>approval required</strong> value of the implementation should not be modified.</p>

<h5 id="s08_01_09_debug_mode">Debug Mode Enabled</h5>
<p>This classifier is used to set the <strong>debug mode enabled</strong> value of the implementation. Leaving this classifier unset indicates that the <strong>debug mode enabled</strong> value of the implementation should not be modified.</p>


<h4 id="s08_02_publishing">Publishing a Runtime Configuration Asset</h4>
<p>When edit is complete on a Runtime Configuration asset, it must be submitted. Once any necessary approvals are complete, the Runtime Configuration is published, and is immediately active.</p>
<p><a href="#top">Back to top</a></p>


<h3 id="s09_orchestrated">Appendix A: Promoting Orchestrated APIs</h3>
<h5 class="stamp">API Platform Version: 2018.0.0 and later</h5>
<p>Unlike a standard proxy-pattern API, APIs implemented as orchestrations could have dependencies on scripts, processes, or services not contained within the API itself. When promotion is requested for an orchestrated API, all such external dependencies are checked to make sure they exist in the target environment. If there are unmet dependencies, the promotion is aborted and a notification specifying the unmet dependencies is provided to the user.</p>
<p>In the case of external scripts and processes, the promotion process attempts to match the referenced script or process in the target environment based on the key of the object.</p>
<p>Mapping of processes and scripts between environments can be specified within a Promotion Profile using the <strong>processMappings</strong> and <strong>scriptMappings</strong> properties respectively. The <strong>processMappings</strong> and <strong>scriptMappings</strong> properties allow you to correlate source and target scripts/processes either by ID or by name.</p>
<p>This section includes the following examples of defining process and script mappings:</p>
<ul>
	<li><a href="#s09_01">By using IDs</a></li>
	<li><a href="#s09_02">By using names</a></li>
	<li><a href="#s09_02">By using</a><a href="#s09_03"> the <strong>match-processes-by-name</strong> and <strong>match-scripts-by-name</strong> properties on the Promotion Profile</a></li>
</ul>

<h5 id="s09_01">
Defining process and script mappings by using IDs</h5>
<p>In the example Promotion Profile below, processes and script mappings are defined using IDs.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "scriptMappings":[
    {
      "sourceScript" : {"scriptId" : "script:7f4fbb16-8389-11e8-af80-80b01a868d88"},
      "targetScript" : {"scriptId" : "script:fb51d840-8399-11e8-af80-80b01a868d88"}
    }
  ],
  "processMappings":[
    {
      "sourceProcess" : {"processId" : "bpel:8c862595-8389-11e8-af80-80b01a868d88"},
      "targetProcess" : {"processId" : "bpel:b2ad95b6-839b-11e8-af80-80b01a868d88"}
    }
  ]
}</pre>

<h5 id="s09_02">Defining process and script mappings by using names</h5>
<p>In the example below, processes and script mappings are defined by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "scriptMappings":[
    {
      "sourceScript" : {"scriptName" : "Dev Script A"},
      "targetScript" : {"scriptName" : "Prod Script A"}
    }
  ],
  "processMappings":[
    {
      "sourceProcess" : {"processName" : "Dev Process A"},
      "targetProcess" : {"processName" : "Prod Process A"}
    }
  ]
}
</pre>

<h5 id="s09_03">Defining process and script mappings by using the match-processes-by-name and match-scripts-by-name properties on the Promotion Profile</h5>
<p>Optionally, the properties <strong>match-processes-by-name</strong> and <strong>match-scripts-by-name</strong> can be set on the Promotion Profile, to allow the promotion logic to map referenced scripts or processes based on the name rather than the key of the object. For example, the example below shows a Promotion Profile allowing matching of both processes and scripts by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties" : [
    {"name":"match-scripts-by-name","value":"true"},
    {"name":"match-processes-by-name","value":"true"}
  ]
}
</pre>

<h4 id="s09_01_referenced_svcs">Referenced Services</h4>
<p>An orchestration of an API operation might use invocation actions to call out to other services. Such invocations specify the target service, operation, and endpoint to use in the invocation. The target service of an invocation must exist in the target environment prior to promoting the orchestrated API. There are two scenarios:</p>
<ul>
	<li><strong>Remote tenants, where keys are preserved across environments</strong>: A service with a matching key must already exist in the target environment.</li>
	<li><strong>Local tenants, where keys are mapped across environments</strong>: The API containing the target service must have been previously promoted using Lifecycle Coordinator.</li>
</ul>
<p>The most common case of service invocation is a call to a physical service. Often, the URL of a physical service is modified for use in the target environment using rules in the Promotion Profile. In this case, the URL of the endpoint of the invocation should be similarly modified. The following example shows the rules that would be defined in a Promotion Profile for changing the host name of physical service URLs along with the invocation references (using the <strong>serviceRef</strong> scope).</p>
<pre>"rules": [
  {
    "scope":"psep",
    "condition":"psep.url.indexOf(\"foo.com\") > 0",
    "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
  },
  {
    "scope":"serviceRef",
    "condition":"serviceRef.url.indexOf(\"foo.com\") > 0",
    "action":"serviceRef.url = serviceRef.url.replace(\"foo.com\",\"bar.com\")"
  }
]
</pre>
<p><a href="#top">Back to top</a></p>



<h3 id="app_b_client_apps">Appendix B: Support for client apps</h3>
<h5 class="stamp">API Platform Version: 2018.0.0 and later</h5>
<p>Currently, the API Platform allows contracts to be established between apps and APIs, but does not support direct API to API access. This can be mitigated through the use of a pattern where an API is represented with a <strong>client App</strong>. With this approach, each API has an accompanying client app that is used to establish access to other APIs for the represented API. Contracts between a client app and another API are logically contracts between the source and target APIs, allowing for full dependency analysis of composite APIs.</p>
<p>You can configure the API Platform Repository plug-in to support the client app pattern by adding the <strong>Create Client App</strong> task to the post-processing phase of the API submission process. For additional information about configuring a submission process, contact Rogue Wave Technical Support. This task will cause a client app to be created as each API is created. The client app will be named as <strong>{api name}_app</strong> and a <strong>client-app</strong> property will be set on the represented API pointing to the client app. The generated client app will, in turn, have a <strong>represented-api</strong> property to point back to the API.</p>
<p>Note that the <strong>Create Client App</strong> task can be configured to run based on the setting of a custom property on the API, such as <strong>isConsumer</strong>, allowing the creator of the API to determine whether a client app is needed.</p>


<h4 id="app_b_promotion_support">Promotion Support</h4>
<p>When an API with an accompanying client app is promoted using Lifecycle Coordinator, the client app will also be promoted to the target environment as well as any contracts it has to other APIs. These contracts will be validated prior to API promotion in the same manner as the dependencies for a standard app are validated prior to app promotion.</p>
<p><a href="#top">Back to top</a></p>