---
layout: page
title: Promotion Guide | Lifecycle Coordinator
description: Learn how to use the Lifecycle Coordinator feature to manage the promotion lifecycle.
product: cm
category: learn
sub-nav-class: Lifecycle Coordinator
weight: 05
type: page
nav-title: LC Promotion Guide
---
<h2 id="top">Lifecycle Coordinator Promotion Guide </h2>
<p>Provides information about how to use the Lifecycle Coordinator feature to manage promotion of assets, such as apps and APIs, from one environment to another. such as from Development to Testing.x</p>
<p><a href="../../sp/install_lc/install_promotion.htm" class="button secondary">Lifecycle Coordinator Installation</a> 
<a href="promotion_samples.htm" class="button secondary">Sample Topologies</a></p>

<h5 class="stamp">API Platform Version: 8.4.3 and later</h5>
<div class = "divider1"></div>


<h3 style="color: gray;">Table of Contents</h3>
<ol class="table_of_contents">
	<li><a href="#overview">Overview</a></li>
	<li><a href="#core_components">Core Components and Component Interaction</a></li>
	<li><a href="#topology_model">Topology Model</a>
		<ol>
			<li><a href="#s03_01">Topology</a></li>
			<li><a href="#s03_02">Tenants</a></li>
			<li><a href="#s03_03">Environments</a></li>
			<li><a href="#s03_04">Promotion Profiles</a></li>
			<li><a href="#s03_05">Asset Filters</a></li>
			<li><a href="#s03_06">Rules</a></li>
			<li><a href="#s03_07_00">Asset Model</a></li>
		</ol>
	</li>
	<li><a href="#lc_installation">Lifecycle Coordinator Installation</a></li>
	<li><a href="#topology_config">Topology Configuration</a>
		<ol>
			<li><a href="#s05_01">Tenants</a></li>
			<li><a href="#s05_02">Environments</a></li>
			<li><a href="#s05_03">Promotion Profiles</a></li>
			<li><a href="#s05_04">Rules</a></li>
			<li><a href="#s05_05">Filters</a></li>
			<li><a href="#s05_06">Organization Mapping</a> (8.4.13 and later)</li>
			<li><a href="#s05_approval_proc">Approval Processes</a> (2018.0.0 and later)</li>
			<li><a href="#s05_07">Policy Mapping</a> (8.4.16 and later)</li>
			<li><a href="#resource_mapping">Resource Mappings (Scope Mapping)</a> (2018.0.0 and later)</li>
			<li><a href="#mapping_visibility_api">API Visibility Mapping</a> (2019.1.0 and later)</li>
			<li><a href="#mapping_visibility_app">App Visibility Mapping</a> (2019.1.0 and later)</li>
			<li><a href="#asset_notification">Asset Notifications</a> (8.4.17 and later)</li>
			<li><a href="#properties_element">Properties</a> (8.4.17 and later)</li>
		</ol>
	</li>
	<li><a href="#dz_configurations">Deployment Zone Configurations</a>
(8.4.12 and later)
	<ol>
			<li><a href="#s06_01">Using Filters with Deployment Zone Configurations</a></li>
			<li><a href="#s06_02">Default Endpoint Propagation</a></li>
			<li><a href="#s06_03">Using Rules with Deployment Zone Configurations</a></li>
			<li><a href="#s06_04">Duplicate Endpoints</a></li>
		</ol>
	</li>
	<li><a href="#s08_03_environment_config">Environment Configuration</a>
		<ol>
		<li><a href="#s08_04_api_impl_profiles">API Implementation Profiles</a></li>
		</ol>
	</li>
	<li><a href="#topology_api">Topology API</a>
		<ol>
			<li><a href="#topologyapi_01">Finding the Topology API Documentation</a></li>
			<li><a href="#topologyapi_02">Using the Topology API</a></li>
		</ol>
	</li>
	<li><a href="#lm_console">Lifecycle Manager Console</a>
		<ol>
			<li><a href="#s07_01">Logging In</a></li>
			<li><a href="#s07_02">Viewing Assets and Iterations</a></li>
			<li><a href="#s07_03">Promotion Requests</a></li>
		</ol>
	</li>
	<li><a href="#env_decoupled_00">Support for Decoupled Environments in a Topology</a></li>
	<li><a href="#runtime_config">Defaulting API Settings using Runtime Configurations</a> (8.4.17 and later)</li>
	<li><a href="#s09_orchestrated">Appendix A: Promoting Orchestrated APIs</a>
		<ol>
			<li><a href="#s09_01_referenced_svcs">Referenced Services</a></li>
		</ol>
	</li>
	<li><a href="#app_b_client_apps">Appendix B: Support for client apps</a> (2018.0.0 and later)</li>
	<li><a href="#app_c_tips">Appendix C: Promotion tips and best practices</a></li>
</ol>
<div class = "divider1"></div>



<h3 id="overview">Overview</h3>
<p>Promotion is the process of propagating versions of a software asset, such as an API, through a series of environments that correspond to the stages of the asset's lifecycle. For example, an API might originate in a development environment, be promoted on to a QA test environment, and finally be promoted to the production environment. Each environment has its own data model that is controlled independently. The Lifecycle Coordinator is a separate configurable component that governs the promotion process and the transfer of data between environments.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="core_components">Core Components and Component Interaction</h3>
<p>The core components in the promotion process are as follows:</p>
<ul>
	<li><a href="#promotion_package">Promotion Package</a></li>
	<li><a href="#source_environment">Source Environment</a></li>
	<li><a href="#target_environment">Target Environment</a></li>
	<li><a href="#lifecycle_coordinator">Lifecycle Coordinator</a></li>
</ul>
<h4 id="promotion_package">Promotion Package</h4>
<p>The Promotion Package holds the data that needs to be promoted from the Source Environment to the Target Environment. The package contains two different artifacts:</p>
<ul>
	<li><strong>The environment data</strong>: The portion of the Source Environment's data model that needs to be promoted.</li>
	<li><strong>A manifest</strong>: Contains configuration details that can be manipulated by rules within the Coordinator before importing the package into the target environment.</li>
</ul>


<h4 id="source_environment">Source Environment</h4>
<p>The Source Environment is the data container that holds the original information that needs to be promoted to the Target Environment. The Source Environment can be managed by its own product instance or it can be managed as a single tenant in a multi-tenant product instance.</p>

<h4 id="target_environment">Target Environment</h4>
<p>The Target Environment is the data container that is the destination of the promoted data from the Source Environment. The Target Environment can be managed by its own product instance or it can be managed as a single tenant in a multi-tenant product instance.</p>

<h4 id="lifecycle_coordinator">Lifecycle Coordinator</h4>
<p>The Lifecycle Coordinator is the component that requests an extraction, or export, of a promotion package from a Source Environment and then initiates the population, or import, of the promotion package to a Target Environment.</p>
<p>The Coordinator processes the manifests contained in the Promotion Package and in the Target Environment's promotion response to maintain a model that reflects the relationship between objects in both environments. On subsequent promotions of the same objects from the Source Environment the Coordinator consults its model and generate a new manifest that will be delivered to the Target Environment.</p>
<p>The Lifecycle Coordinator is a separate component from the environments but can be co-deployed on the same instance.</p>

<h4>Component Interaction</h4>
<p><img src="images/promotion_01.jpg" alt="Component interaction" /></p>
<p>When promotion is requested from the Source Environment, the Lifecycle Coordinator exports a Promotion Package from that Environment and imports the package in the Target Environment.</p>
<p>The Lifecycle Coordinator persists its own model of objects and their relationships in all the environments it has performed promotions for. The Coordinator consults its model to see if the objects identified in the Promotion Package's manifest are already present. If the objects are not in the model, the Coordinator adds them. If the objects are in the model the Coordinator extracts the corresponding object IDs of the Target Environment and create a new manifest with the Target Environment's object IDs.</p>
<p>The Lifecycle Coordinator initiates an import of the Promotion Package in the Target Environment using an Import API. The Target Environment uses the manifest to identify the objects in its own data model that are in the Promotion Package; if objects already exist, a Modify action is performed. If the Promotion Package objects are new to the Target Environment an Add action is performed. The object IDs in the manifest are used in the Target Environment, not the object IDs found in the export content, which are still the IDs found in the Source Environment.</p>
<p>Upon completion of the Import API call a response is returned to the Lifecycle Coordinator. A manifest is included in that response that identifies the objects and relationships that were the result of the import in the Target Environment. The Lifecycle Coordinator processes this manifest and updates its own model for subsequent promotion calls.</p>
<p>The Lifecycle Coordinator can be deployed in a container separate from the API Platform(s) it governs promotions over. In this deployment, the interactions between the Lifecycle Coordinator and API Platform(s) are performed using RESTful interfaces. The Coordinator can promote between environments in the same system:</p>
<p><img src="images/promotion_02.jpg" alt="Environments in the same system" /></p>
<p>Or the Coordinator can promote between environments in separate systems.</p>
<p><img src="images/promotion_03.jpg" alt="Environments in different systems" /></p>
<p>The Lifecycle Coordinator can also be deployed in the same container as the API Platform. Whether multiple tenants are associated with Environments or just one tenant the deployment and interaction is the same. All interactions are performed using in-memory interfaces.</p>
<p><a href="#top">Back to top</a></p>




<h3 id="topology_model">Topology Model</h3>

<h4 id="s03_01">Topology</h4>
<p>A Topology defines a sequence of Environments and the specific behavior for promotion between these Environments.</p>
<p><img src="images/promotion_04.jpg" alt="Promotion behavior between environments" /></p>

<h4 id="s03_02">Tenants</h4>
<p>Tenants are defined at the top level of the Topology and represent a Community Manager (CM) tenant that may be local (within the same container) or remote from the Lifecycle Coordinator. Tenants are referenced by Environments via an id assigned to the tenant in its definition. While an Environment must reference a tenant, the same Tenant may be referenced by more than one Environment. Tenants contain information allowing the Lifecycle Coordinator to communicate with the associated CM Tenant, this includes the tenant's address, name and admin credentials.</p>
<p>A Tenant that is local may also indicate that it should be used to as an authentication source for users approving promotion requests with the Lifecycle Coordinator.</p>

<h4 id="s03_03">Environments</h4>
<p>An Environment represents a logical container to which an asset is deployed at a specific stage of its lifecycle. An Environment must specify the Tenant that supports it.</p>
<p>Environments also define the possible transitions to the next Environment in the form of Promotion Profiles. At this time, only a single target Environment can be specified in the promotion chain (Environment fan-out is not currently supported).</p>

<h4 id="s03_04">Promotion Profiles</h4>
<p>Promotion Profiles represent a transition to the next (<strong>target</strong>) Environment. A promotionProfile specifies a target Environment and optionally a set of Rules to be applied to the manifest of the promotion package of the asset prior to promotion into the target Environment. A promotionProfile might also, optionally, specify an Asset Filter. This allows multiple promotionProfiles to be defined within an Environment with mutually exclusive filters, each with a different rule set. When promotion of an asset is requested from a source Environment, and more than one promotionProfile exists, the promotionProfile with an Asset Filter that the asset complies with is used. In the case where only one promotionProfile exists (with no Asset Filter specified), that promotionProfile is automatically selected for the promotion.</p>


<h4 id="s03_05">Asset Filters</h4>
<p>Asset Filters contain a set of criteria for the custom properties of the assets being promoted. For example, an API asset may use a custom property indicating that it is PCI compliant. An Asset Filter can define criteria for that property such that only API assets that are PCI compliant will match the filter. This Asset Filter can then be assigned to a Promotion Profile such that a different set of Rules are applied to PCI-compliant and non-compliant API assets.</p>
<p class="apidoc_note"><strong>Note</strong>: the use of Asset Filters requires custom properties to be enabled for the tenants involved in the promotion.</p>


<h4 id="s03_06">Rules</h4>
<p>A Promotion Profile may optionally contain a set of rules to guide the need for changes in relationships and properties when assets are promoted. A rule consists of a condition and a behavior. The rule is provided a context when evaluated made up of an asset's properties. The condition of the rule is a Boolean expression evaluated against that context. The behavior of the rule is an expression that alters that context. The expression language used by the rule engine is JEXL. A set of syntax examples can be found at <a href="https://commons.apache.org/proper/commons-jexl/reference/syntax.html" title="https://commons.apache.org/proper/commons-jexl/reference/syntax.html" target="_blank">https://commons.apache.org/proper/commons-jexl/reference/syntax.html</a>. Each asset in a promotion package is run through the rule engine. If any asset meets the condition of the rule, the behavior is performed against it. Some examples of rules are below.</p
>
<table cellspacing="0px" class="doctable" style="width: 98%;">
	<thead>
		<tr>
			<th width="33%">Condition</th>
			<th width="33%">Behavior</th>
			<th width="33%">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>vsep.containerKey = "ND1"</td>
			<td>vsep.containerKey = "ND2"</td>
			<td>Changes hosting relationship from ND1 to ND2</td>
		</tr>
		<tr>
			<td>apiversion.implType = "Sandbox"</td>
			<td>vsep.containerKey = "ND2"</td>
			<td>Changes hosting relationship for sandbox implementations</td>
		</tr>
		<tr>
			<td>vsep.containerKey = "ND1" &amp;&amp; vsep.listenerName = "http"</td>
			<td>vsep.containerKey = "ND2";
vsep.listenerName = "https"</td>
			<td>Changes both the container and listener</td>
		</tr>
		<tr>
			<td>psep.url.startsWith("http://oldhost")</td>
			<td>psep.url.replace("http://oldhost", "http://newhost")</td>
			<td>Changes the host of a target endpoint</td>
		</tr>
		<tr>
			<td>apiversion.tags.contains("secret")</td>
			<td>apiversion.tags.add("probation")</td>
			<td>Adds a tag based on the presence of another.</td>
		</tr>
		<tr>
			<td>classifier:internal = "true"</td>
			<td>vsep.containerKey = "ND3"</td>
			<td>Sets container based on the value of a custom classifier</td>
		</tr>
	</tbody>
</table>

<h4 id="s03_07_00">Asset Model</h4>
<p>The Lifecycle Coordinator component is an extension of the Lifecycle Repository core functionality. As such, it uses an internal asset model to represent the topology and the assets promoted through the topology. Within the Lifecycle Coordinator, promotion requests result in the submission of an asset into the target environment, allowing for customized governance to be defined for this process.</p>
<p>In this section:</p>
<ul>
	<li><a href="#s03_07_01">Topology Asset Model</a></li>
	<li><a href="#s03_07_02">Promotable Asset Model</a></li>
	<li><a href="#s03_07_03">OrgGroup Assignment</a></li>
</ul>

<h5 id="s03_07_01">Topology Asset Model</h5>
<p>The topology asset model reflects the conceptual topology model defined earlier in this document with asset types for Environment, Tenant and Promotion Profile. The following diagram shows the asset structure for a Topology with three Environments (each box representing an asset):</p>
<p><img src="images/promotion_05.jpg" alt="Topology asset model, three environments" /></p>
<p>In addition to the relationships shown, Tenant assets contain connection information and credentials as classifiers while Promotion Profile assets hold Rules as a JSON artifact. Asset Filters are managed implicitly and optionally referenced by Promotion Profile assets.</p>


<h5 id="s03_07_02">Promotable Asset Model</h5>
<p>Promotable assets such as APIs are represented by specific asset-types. These asset types reference an Environment asset and contain <strong>Iteration</strong> assets representing each promotion of that asset. Note that there is a difference between <strong>versions</strong> of assets such as APIs and <strong>iterations</strong>: a single version of an API may be promoted multiple times, resulting in multiple iterations of that version. In the following asset diagram, the asset <strong>AnAPI (v1)</strong> has been promoted from development to integration test and then to production environments once, followed by another promotion from development to integration test. This resulted in two iterations in the development and integration test environments with a single iteration at production. Notice that the iteration at production indicates that its source iteration is iteration 1 in integration test, even though there is a newer iteration (iteration 2) in that environment.</p>
<p><img src="images/promotion_06.jpg" alt="Promotable asset model" /></p>
<p>Iterations contain several items:</p>
<ul>
	<li>A timestamp indicating when the promotion took place</li>
	<li>The user that requested the promotion</li>
	<li>The status of the promotion. Values for the status are:
		<ul>
			<li><strong>Promotion Pending</strong>: Promotion has been requested but has not been completed. It may be pending one or more approvals.
			<p><strong>Note</strong>: In the case where an approval process is in place and a promotion request is rejected, the Iteration will remain in a Promotion Pending state. However, the API platform UI will show it as <strong>Promotion Rejected</strong>, allowing promotion to be requested again.</p></li>
			<li><strong>Promoted</strong>: Promotion has completed.</li>
			<li><strong>Promotion Failed</strong>: There was a failure in the promotion process. Promotion can be requested again for assets in this state. The next promotion attempt will replace the failed iteration.</li>
		</ul>
			<p><strong>Note</strong>: The API Platform UI also indicates a <strong>Not Promoted</strong> state. This corresponds to an asset not yet existing in the target environment. Such assets will not be present in Lifecycle Coordinator.</p>
	</li>
	<li>The promotion package that was imported into the target environment is held as an artifact called archive.zip.</li>
	<li>In the case of a promotion failure the iteration includes a short summary of the exception causing the failure.</li>
	<li>A relationship to the source iteration in the source environment</li>
	<li>A relationship to the previous iteration (if one exists) in the target environment</li>
	<li>A relationship to the Promotion Profile selected for promotion of the asset.</li>
</ul>

<h5 id="s03_07_03">OrgGroup Assignment</h5>
<p><strong>API Platform Version: 8.4.13 and later</strong></p>
<p>When promotion is requested for an asset such as an API, the asset is assigned an owning OrgGroup within Lifecycle Coordinator. These OrgGroups correspond to the asset's Organization in the corresponding API Platform environment. This approach allows promotion approvers to be assigned at an organizational level within the Lifecycle Coordinator topology.</p>
<span class="apidoc_note"><strong>Note</strong>: OrgGroups are synchronized with the tenant Organization when a topology is created or updated. If an asset is promoted with an Organization for which there is no corresponding OrgGroup, Lifecycle Coordinator synchronizes the Organizations for the corresponding tenant in an attempt to resolve the missing OrgGroup.</span>
<p><a href="#top">Back to top</a></p>




<h3 id="lc_installation">Lifecycle Coordinator Installation</h3>
<p>For installation information, refer to <a href="../../sp/install_lc/install_promotion.htm">Lifecycle Coordinator Installation</a>.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="topology_config">Topology Configuration</h3>
<p>The Lifecycle Coordinator feature provides a REST API for maintaining topologies. This allows topologies to be defined in JSON structure. The following example shows the definition of a topology consisting of two environments supported by two local tenants.</p>
<pre>{
  "name":"Topology1",
  "tenants":[
    {
      "name":"DevelopmentTenant",
      "id":"tenant1",
      "credentials":{
        "email":" administrator1@example.com ",
        "password":"password1"
      }
    },
    {
      "name":"ProductionTenant",
      "id":"tenant2",
      "userAuthenticationSource":true,
      "credentials":{
        "email":"administrator2@example.com",
        "password":"password2"
      }
    }
  ],
  "environments":[
    {
      "name":"development",
      "displayName":"Development",
      "description":"Development environment",
      "tenant":"DevelopmentTenant",
      "promotionProfiles":[
        {
          "name":"Default Production Promotion",
          "description":"Dev to production default profile",
          "targetEnvironment":"production"
        }
      ]
    },
    {
      "name":"production",
      "displayName":"Production",
      "description":"Production environment",
      "tenant":"ProductionTenant"
    }
  ]
}</pre>



<h4 id="s05_01">Tenants</h4>
<p>This section includes:</p>
<ul>
	<li><a href="#s05_01_tenantdefinitions">Tenant Definitions</a></li>
	<li><a href="#s05_01_tenantnames">Tenant Names</a></li>
	<li><a href="#s05_01_delegatedauth">Delegated Authentication</a></li>
	<li><a href="#s05_01_tenantproperties">Tenant Properties (8.4.18 and later)</a></li>
</ul>
<h5 id="s05_01_tenantdefinitions">Tenant Definitions</h5>
<p>Tenant definitions in the topology provide the Lifecycle Coordinator the necessary information to communicate with the specified tenant. Tenants can be either local (on the same container as the Lifecycle Coordinator) or remote. When defining a tenant:</p>
<ul>
	<li><strong>Local</strong> tenant: Specify the tenantId in the <strong>id</strong> property, as in the topology example above.</li>
	<li><strong>Remote</strong> tenant: In addition to the tenantId in the <strong>id</strong> property as above, specify the address of the tenant in the <strong>address</strong> field.</li>
</ul>
<p>The example below shows both values:</p>
<pre>{
  "name":"ProductionTenant",
  "id":"tenant2",
  "address":"http://myProductionTenant:9900",
  "credentials":{
    "email":"administrator2@example.com",
    "password":"password2"
  }
}</pre>
<p class="apidoc_note"><strong>Note</strong>: The address value is unique to the tenant. It corresponds to the value specified for the <strong>address</strong> parameter when the tenant was created.</p>

<h5 id="s05_01_tenantnames">Tenant Names</h5>
<p>Tenants require a <strong>name</strong> property which is used to identify the tenant by environments within the topology. This name must be unique within the topology, but need not correspond to the actual tenant name.</p>

<h5 id="s05_01_delegatedauth">Delegated Authentication</h5>
<p>In the promotion profile, you can indicate that authentication for the underlying Lifecycle Repository library is delegated to a specified tenant. This means that users of the specified tenant can log in to the topology library using their email and password for that tenant.</p>
<p>There are two ways you can do this:</p>
<ol>
	<li>By using the <strong>userAuthenticationSource</strong> property.
		<p>You can set the Boolean <strong>userAuthenticationSource</strong> property within a Tenant definition to indicate that the tenant will be used for authentication.</p>
<p>Only one tenant can have the <strong>userAuthenticationSource</strong> property set to <strong>true</strong>, and that tenant must be local to the Lifecycle Coordinator. This delegates user definition and authentication to the specified local tenant (a tenant in the same container that Lifecycle Coordinator is deployed in).</p>
<p>An example is shown below.</p>
<pre>{ 
  &quot;name&quot;:&quot;DevelopmentTenant&quot;,
  &quot;id&quot;:&quot;tenant1&quot;,
  &quot;credentials&quot;:{ 
    &quot;email&quot;:&quot;administrator1@roch.soa.local&quot;,
    &quot;password&quot;:&quot;password1&quot;
  },
  &quot;userAuthenticationSource&quot;:true
},</pre>
</li>
	<li>By setting a tenant ID using the topology-scoped <strong>authentication-tenant-id</strong> property. (2018.0.0 and later)
	<p>In version 2018.0.0, Lifecycle Coordinator relies on the Akana API Platform for user authentication. Since Lifecycle Coordinator is often deployed separately from tenants in the topology, it might be necessary to delegate authentication and user management to a local tenant that is not in the topology.</p>
	<p>A tenant specified with the <strong>authentication-tenant-id</strong> property must be local, but doesn't need to be part of the topology.</p>
	<p>An example is shown below.</p>
	<pre>{
  "name": "Topology1",
  "properties": [
    {"name":"authentication-tenant-id","value":"authtenant"}
  ],
...</pre>
	</li>
</ol>
<p>If neither of these approaches is used to specify the authentication tenant, the authentication tenant ID defaults to <strong>lifecycle_coordinator</strong>.</p>
<h5 id="s05_01_tenantproperties">Tenant Properties (8.4.18 and later)</h5>
<p>Tenant definitions can contain optional properties, as shown in the example below.</p>
<pre>{
  "name":"ProductionTenant",
  "id":"tenant2",
  "address":"http://myProductionTenant:9900",
  "credentials":{
    "email":"administrator2@example.com",
    "password":"password2"
  },
  "properties":[
    {
      "name":"virtual-address",
      "value":"http://myCompany:9950"
    }
  ]
}</pre>
<p>The optional properties available for a tenant are:</p>
<ul>
	<li><strong>virtual-address</strong>: This property can be used when the URL used to access a remote tenant is different from the tenant's address attribute. For example, this property would be used if the tenant is fronted by a load balancer. If the <strong>virtual-address</strong> property is provided, the URL set in the value of this property is used for all communications with the tenant.</li>
</ul>


<h4 id="s05_02">Environments</h4>
<p>Environments reference a corresponding tenant and hold one or more promotionProfiles representing transitions to other environments.</p>


<h5>Environment Names</h5>
<p>The <strong>name</strong> property for an environment must be unique within the topology and should not be changed once defined. This is because this name is used as a key for mapping information between environments stored by the Lifecycle Coordinator. Given the invariability of the environment name, a <strong>displayName</strong> property is also supported. The display name is what appears to users in the API Platform UI and may be changed without affecting mapping information.</p>

<h4 id="s05_03">Promotion Profiles</h4>
<p>Promotion Profiles are defined within the <strong>promotionProfiles</strong> property of an Environment. The <strong>targetEnvironment</strong> property of a PromotionProfile must correspond to the <strong>name</strong> of another Environment in the Topology.</p>
<p>A PromotionProfile can optionally specify one or more filters by specifying filter names within the <strong>filterNames</strong> array property.</p>
<p>Rule definitions might optionally be provided using the <strong>rules</strong> array property.</p>
<p class="apidoc_note"><strong>Note</strong>: A PromotionProfile cannot create a cycle between Environments.</p>


<h4 id="s05_04">Rules</h4>
<p>Rules are defined inline within the <strong>rules</strong> array property of a PromotionProfile. Each Rule consists of a <strong>scope</strong> property indicating the property in the archive manifest it applies to, an optional <strong>condition</strong> property indicating the conditions for which the Rule applies and a required <strong>action</strong> property indicating the action to perform on the manifest property.</p>
<p>Examples in this section:</p>
<ul>
	<li><a href="#s05_04_01">Rule example #1</a>: changes the hostname for the physical service endpoint.</li>
	<li><a href="#s05_04_02">Rule example #2</a>: changes the name of the OAuth provider for a promoted API in the target environment.</li>
</ul>
<h5 id="s05_04_01">Rule example #1</h5>
<p>In this example, the rule changes the host name of the physical service endpoint (<strong>psep</strong>) for an API:</p>
<pre>{
  "scope":"psep",
  "condition":"psep.url.indexOf(\"foo.com\") > 0",
  "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
}</pre>
<p>Note the use of '\' to escape the double quotes in the condition and action.</p>

<h5 id="s05_04_02">Rule example #2</h5>
<p>The example below changes the name of the OAuth provider for a promoted API in the target environment.</p>
<p><strong>Note</strong>: Only use this rule if the configuration of the source and target OAuth Providers is identical, including scope definition. If the configuration is not identical, using this rule might cause promotion errors.</p>
<pre>{
  "scope" : "vs",
  "condition" : "vs.oauthProvider == 'SourceProvider'",
  "action" : "vs.oauthProvider = 'TargetProvider'"
}</pre>


<h4 id="s05_05">Filters</h4>
<p>The <strong>filters</strong> property of a Topology allows asset filters to be defined for use in PromotionProfile selection. Filters contain criteria which apply to the classifiers associated with an asset.</p>
<p>Filters correspond to the <strong>custom properties</strong> for an API in the API Platform UI.</p>
<p>The following example defines filters used to differentiate between APIs that are PCI compliant and those that are not based on a <strong>pci-compliant</strong> classifier:</p>
<pre>[
  {
    "name":"PCI Compliant",
    "classifier-criteria":[
      {
        "classifierName":"pci-compliant",
        "values":[
          {
            "value":"true"
          }
        ]
      }
    ]
  },
  {
    "name":"PCI Non-Compliant",
    "classifier-criteria":[
      {
        "classifierName":"pci-compliant",
        "values":[
          {
            "value":"false"
          }
        ]
      }
    ]
  }
]
</pre>
<p>With these filters defined, different transition paths between source and target Environments can be defined as in the following example <strong>promotionProfiles</strong> property for an Environment:</p>
<pre>{
  "promotionProfiles":[
    {
      "name":"PCI Production Promotion",
      "targetEnvironment":"Production",
      "filterNames":[
        "PCI Compliant"
      ],
      "rules":[
        {
          "scope":"vsep",
          "action":"vsep.containerKey = '{pci-container-key}' "
        }
      ]
    },
    {
      "name":"Non-PCI Production Promotion",
      "targetEnvironment":"Production",
      "filterNames":[
        "PCI Non-Compliant"
      ],
      "rules":[
        {
          "scope":"vsep",
          "action":"vsep.containerKey = '{standard-container-key}' "
        }
      ]
    }
  ]
}</pre>
<p><a href="#top">Back to top</a></p>


<h4 id="s05_approval_proc">Approval Processes</h4>
<p><strong>API Platform Version: 2018.0.0 and later</strong></p>
<p>Simple approval processes involving one or two approver roles can be defined within a PromotionProfile using the <strong>approvalProcesses</strong> property to call out (in order) the approval roles for the promotion to the target environment. For example, the following PromotionProfile definition for transition to the production environment requires approval from a user with the <strong>Architect</strong> role, followed by approval from a user with the <strong>Promotion Manager</strong> role.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "approvalProcesses": [
    {
      "type": "api",
      "approvals": [
        "Architect",
        "Promotion Manager"
      ]
    }
  ]
}</pre>
<p>The specification of roles in the approvals property causes the specified roles to be implicitly created in the topology library, where users can then be assigned to the roles.</p>
<p>This declarative approach to approval definition is intended to address simple approval processes that do not required property-based filtering, require more than two approval roles, or require special pre- or post-processing tasks. To define advanced approval processes such as this, use Configuration Designer.</p>
<p>Note that if any PromotionProfile in the topology definition defines an approvalProcess, Lifecycle Coordinator assumes that it is managing all submission processes and custom roles for the underlying library and overwrites any customization of those processes or manually defined roles. If the PromotionProfile includes advanced process configuration, do not include approvalProcesses in the topology definition.</p>
<p><a href="#top">Back to top</a></p>


<h4 id="s05_06">Organization Mapping</h4>
<p><strong>API Platform Version: 8.4.13 and later</strong></p>
<p>Lifecycle Coordinator attempts to assign APIs in the target environment tenant to an Organization matching the name of the Organization in the source environment tenant. If it doesn't find an Organization of the same name, it assigns the API to the tenant Organization.</p>
<p>Within a promotion profile, you can define a rule to create a mapping of Organizations when promoting to the target environment. To do this, define a rule that modifies the <strong>api.orgName</strong> property.</p>
<p>For example, you could add the following rule to the rules of a PromotionProfile to map APIs from the source Organization <strong>GroupA</strong> to the target Organization <strong>GroupB</strong>.</p>
<pre>{
  "scope":"api",
  "condition":"api.orgName == 'GroupA'",
  "action":"api.orgName = 'GroupB'"
}</pre>



<h4 id="s05_07">Policy Mapping</h4>
<p><strong>API Platform Version: 8.4.16 and later</strong></p>
<p>A Promotion Profile can optionally contain a set of PolicyMappings that you can use to tailor the propagation and validation of policy references when an API is promoted to the target environment. You can use PolicyMappings to:</p>
<ul>
	<li>Map a policy reference in the source environment to a policy in the target environment.</li>
	<li>Remove a policy reference altogether when an API is promoted.</li>
</ul>
<p>A PolicyMapping has one of these two properties:</p>
<ul>
	<li><strong>sourcePolicy</strong>&#8212;Used to identify a specific policy in the source environment by either name or unique id.</li>
	<li><strong>sourcePolicyFilter</strong>&#8212;Used to specify a group of policies by type or subtype.</li>
</ul>
<p>Additionally, a PolicyMapping can specify a <strong>targetPolicy</strong> in the target environment either by name or unique id.	If a PolicyMapping does not specify a <strong>targetPolicy</strong> property, references to policies matching the <strong>sourcePolicy</strong> or <strong>sourcePolicyFilter</strong> property are ignored when an API is propagated to the next environment.</p>
<p>The following PromotionProfile shows an example of a PolicyMapping that maps references to the DetailedAuditPolicy in the source environment to the BasicAuditPolicy in the target environment:</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "rules": [],
  "policyMappings": [
    {
      "sourcePolicy": {
        "policyName": "DetailedAuditing"
      },
      "targetPolicy": {
        "policyName": "BasicAuditing"
      }
    }
  ]
}</pre>

<p>In this example, the PolicyMapping uses the unique ids of the source and target policies:</p>
<pre>{
  "sourcePolicy": {
    "policyId": "urn:uuid:852afbc5-101e-11e8-887b-abe2ebb3db33"
  },
  "targetPolicy": {
    "policyId": "urn:uuid:763b7ca5-304f-16e8-457b-c542e456db33"
  }
}</pre>
<p>You can accomplish a  one-to-many mapping of policies using a policy filter:</p>
<pre>{
  "sourcePolicyFilter": {
    "policyType": "Operational Policy",
    "policySubtype" : "policy.auditservice"
  },
  "targetPolicy": {
    "policyName": "BasicAuditing"
    }
}</pre>
<p>A specific policy is disabled on promotion by omitting the targetPolicy property in the PolicyMapping:</p>
<pre>{
  "sourcePolicy": {
    "policyName": " DetailedAuditing "
  }
}</pre>

<h5>Default Mappings</h5>
<p>Policies that are available by default within a tenant, such as DetailedAuditing, BasicAuditing, and CORSAllowAll, are implicitly mapped to the corresponding default policies in the target tenant and do not need an explicit PolicyMapping. You can think of this default mapping as being of the form:</p>
<pre>{
  "sourcePolicy": {
    "policyId": "&lt;source tenant id&gt;-&lt;policy name&gt;"
  },
  "targetPolicy": {
    "policyId": "&lt;target tenant id&gt;-&lt;policy name&gt;"
  }
}
</pre>

<h5 id="s05_07_03">Tenant name change: original-tenant-name property</h5>
<p>Default policy mappings are determined based on the tenant name. If the name of a tenant was changed since its original creation (in the Developer Portal, <strong>Admin</strong> > <strong>Site</strong>), it's important to include the original tenant name in the tenant definition in the topology, using the <strong>original-tenant-name</strong> property. An example is shown below.</p>
<pre>{ 
  "id": "devtenant", 
  "name": "DevelopmentTenant", 
  "address": "http://devacmepaymentscorptenant:9457", 
  "properties": [ 
    { 
      "name": "original-tenant-name", 
      "value": "Tenant1" 
    } 
  ], 
  ... 
}</pre>


<h5>Policy Validation</h5>
<p>When an API is promoted, policy references must do one of the following:</p>
<ul>
	<li>Reference a default policy, such as DetailedAuditing</li>
	<li>Match the unique ID of an existing policy in the target environment</li>
	<li>Match a PolicyMapping defined for the selected PromotionProfile </li>
</ul>
<p>If none of the above criteria are met, a validation error is returned to the promoting user and the promotion is aborted.</p>
<p><a href="#top">Back to top</a></p>


<h4 id="resource_mapping">Resource Mappings (Scope Mapping)</h4>
<p><strong>API Platform Version: 2018.0.0 and later</strong></p>
<p>A PromotionProfile can, optionally, include a set of ResourceMappings that can be used to tailor the propagation and validation of resource references representing the <strong>scopes</strong> assigned to an API and its operations as the API is promoted to the target environment.</p>
<p>A ResourceMapping consists of a <strong>sourceResource</strong> and a <strong>targetResource</strong> property, each specifying either the name or ID of a resource in the respective environment. The following PromotionProfile shows an example of a ResourceMapping that maps a resource (scope) by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "resourceMappings": [
    {
      "sourceResource": {"resourceName" : "DevScope1"},
      "targetResource": {"resourceName" : "ProdScope1"}
    }
  ]
}</pre>
<p>Resource mapping can also be done with unique IDs. In the example below, the ResourceMapping uses the unique IDs of the source and target resources.</p>
<pre>{
  " sourceResource ":{
    "resourceId":"aa6d2ae0-299d-47d1-a899-f7e6be1b781a.tenant1"
  },
  " targetResource ":{
    "resourceId":"3456bae0-299d-47d1-7799-f7e6be1b221a.tenant2"
  }
}</pre>

<h5 id="resource_mapping_default">Default Mapping</h5>
<p>By default, Lifecycle Coordinator maps resources (scopes) based on matching names. This means that references from an API to a scope in the source environment will be mapped to a scope of the same name (if it exists) in the target environment regardless of the IDs of the scopes. You can change this default behavior by setting the <strong>match-resources-by-name</strong> property on the PromotionProfile to <strong>false</strong> as shown below.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties": [
    {"name": "match-resources-by-name","value": "false"}
  ]
}</pre>

<h5 id="resource_validation">Resource Validation</h5>
<p>By default, if a resource referenced by an API or its operations does not match a resource in the target environment (either by ID, by resource mapping, or by default name matching behavior), promotion of the API will proceed without error with the resource reference removed from the promoted API.</p>
<p>You can change this behavior by setting the <strong>validate-api-resources</strong> property on the PromotionProfile to <strong>true</strong>, as shown in the example below.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties": [
    {"name": "validate-api-resources","value": "true"}
  ]
}</pre>
<p>With the <strong>validate-api-resources</strong> property set to <strong>true</strong>, promotion of an API with an unmatched resource reference will be aborted. A validation error is displayed to the user attempting to promote the resource.</p>


<h4 id="mapping_visibility_api">API Visibility Mapping</h4>
<p><strong>API Platform Version: 2019.1.0 and later</strong></p>
<p>A PromotionProfile can include a set of ResourceMappings that can be used to tailor the visibility of an API version when the API is promoted to the target environment.</p>
<p>For example, in the source tenant the API version visibility might be set to Public, but you might want to set it to Private in the target tenant. You could accomplish that with the rule shown below.</p>
<pre>"rules":[
  {
    "scope":"apiVersion",
    "condition":"apiVersion.visibility == 'Public'",
    "action":"apiVersion.visibility = 'Private'"
  }
]</pre>






<h4 id="mapping_visibility_app">App Visibility Mapping</h4>
<p><strong>API Platform Version: 2019.1.0 and later</strong></p>
<p>A PromotionProfile can include a set of ResourceMappings that can be used to tailor the visibility of an app version when the app is promoted to the target environment.</p>
<p>For example, in the source tenant the app version visibility might be set to Registered Users, but you might want to set it to Private in the target tenant. You could accomplish that with the rule shown below.</p>
<pre>"rules":[
  {
    "scope":"appVersion",
    "condition":"appVersion.visibility == 'Registered Users'",
    "action":"appVersion.visibility = 'Private'"
  }
]</pre>


<h4 id="asset_notification">Asset Notifications</h4>
<p><strong>API Platform Version: 8.4.17 and later</strong></p>
<p>A PromotionProfile can optionally specify updates to be made to instances of an API, within environments of a topology, on completion of a successful promotion. These updates are implemented as changes to the values of custom properties on the API within a specified environment.</p>
<p>For example, let's assume a topology consisting of three environments: <strong>Development</strong>, <strong>Test</strong>, and <strong>Production</strong>. The goal is to mark the instances of an API in the Development and Test environments as <strong>in production</strong> once the API is successfully promoted to the Production environment.</p>
<p>Steps:</p>
<ol>
	<li>The Development and Test tenants could be configured to support an <strong>in-production</strong> Boolean custom property.</li>
	<li>Then, the PromotionProfile representing the promotion from Test to Production would specify the property to update, the value to set the property to, and the environments in which the property is to be set.</li>
</ol>
<p>This is shown in the following PromotionProfile declaration:</p>
<pre>{
  "name":"Default Production Promotion",
  "targetEnvironment":"production",
  "assetNotifications":[
    {
      "propertyName":"in-production",
      "propertyValue":"true",
      "environments":[
        "development",
        "test"
      ]
    }
  ]
}</pre>
<p>This feature relies on custom properties having been enable for the notified tenants, and on the specified property existing on the target API.</p>


<h4 id="properties_element">Properties</h4>
<p><strong>API Platform Version: 8.4.17 and later</strong></p>
<p>A PromotionProfile can optionally specify properties to further refine export/import behavior. These are defined in an optional <strong>properties</strong> element, as shown in the examples below.</p>
<p>You can set the following properties on a PromotionProfile:</p>
<ul>
	<li><a href="#props_export_pki">export-pki</a></li>
	<li><a href="#props_match_policies_by_name">match-policies-by-name</a></li>
	<li><a href="#props_preserve_outbound_identities">preserve-outbound-identities</a></li>
	<li><a href="#props_preserve_shared_secret">preserve-shared-secret</a></li>
	<li><a href="#props_disable_consumer_app_check">disable-consumer-app-check</a></li>
</ul>
<p>For exampples, see <a href="#props_examples">Properties: examples</a>.</p>

<h5 id="props_export_pki">export-pki</h5>
<p>This option indicates that the PKI keys and certificate for an API will be included in the promotion if they exist. Note that if the target environment for a promotion is on a different container from the source environment, the API's certificate or an ancestor in the chain must be trusted by the target container's certificate authority, or it will be ignored when importing the API.</p>
<p>A value of <strong>true</strong> indicates that PKI keys and certificate should be promoted. The default value for this property is <strong>false</strong>.</p>

<h5 id="props_match_policies_by_name">match-policies-by-name</h5>
<p>Setting this property to a value of <strong>true</strong> indicates that custom policies in the source and target environments are to be implicitly mapped by policy name (regardless of their unique keys).</p>
<p>For example, without this property present, an API referencing a policy named <strong>MyCustomAuditingPolicy</strong> in the source environment will fail validation even if there is a policy with the same name in the target environment, unless there is a policy mapping explicitly defined between the policies. With the property set to <strong>true</strong>, the API will pass validation and will be assigned the policy with the same name in the target environment.</p>

<h5 id="props_preserve_outbound_identities">preserve-outbound-identities</h5>
<p><strong>API Platform Version: 2019.1.0 and later</strong></p>
<p>Setting this property to a value of <strong>true</strong> indicates that the outbound identities of an existing service are not changed as a result of the promotion process.</p>
<p>For example, without this property present, the target API identity mapping is overwritten with the values set in the source API. With the property set to <strong>true</strong>, the identities in the target API are not affected by promoting the API. The original values are preserved in the target API.</p>

<h5 id="props_preserve_shared_secret">preserve-shared-secret</h5>
<p><strong>API Platform Version: 2020.0.0 and later</strong></p>
<p>Setting this property to a value of <strong>true</strong> indicates that the shared secret of an existing app in the target environment, is not changed as a result of the promotion process.</p>
<p>Without this property present, the app shared secret value in the target environment is overwritten with the app shared secret value from the source environment. With this property set to <strong>true</strong>, the shared secret value in the target app is not affected by promoting the app. The original value is preserved in the target app.</p>

<h5 id="props_disable_consumer_app_check">disable-consumer-app-check</h5>
<p><strong>API Platform Version: 2020.0.0 and later</strong></p>
<p>Setting this property to a value of <strong>true</strong> indicates that the promotion process will not check for a consumer app and will not fail if the consumer app is not present.</p>
<p>In some cases, you might have a consumer flag on an API, that creates a consumer app for the API and ties the two together. In this scenario, for promotion to be successful, it's best to disable the consumer app check. Otherwise, promotion might fail.</p>
<p>If this property is not present, or is set to <strong>false</strong>, the existing API promotion behavior is applied.</p>
<h5 id="props_examples">Properties: examples</h5>
<p>Example #1: sets the <strong>export-pki</strong> value.</p>
<pre>{
  "name":"Default Production Promotion",
  "description":"Dev to production default profile",
  "targetEnvironment":"production",
  "properties":[
    {
      "name":"export-pki",
      "value":"true"
    }
  ]
}</pre>
<p>Example #2: Sets <strong>match-policies-by-name</strong> and <strong>preserve-outbound-identities</strong>.</p>
<pre>{
  "name":"Topology",
  "environments":[
    {
      "name":"dev1",
      "displayName":"dev1",
      "description":"Development environment",
      "tenant":"dev1",
      "initialEnvironment":true,
      "promotionProfiles":[
        {
          "name":"Default Testing Promotion",
          "description":"Dev to Testing default profile",
          "targetEnvironment":"test1",
          "properties":[
            {
              "name":"match-policies-by-name",
              "value":"true"
            },
            {
              "name":"preserve-outbound-identities",
              "value":"true"
            }
          ]
        }
      ]
    },
    {
      "name":"test1",
      "displayName":"test1",
      "description":"Testing environment",
      "tenant":"test1"
    }
  ],
  "tenants":[
    {
      "name":"dev1",
      "userAuthenticationSource":true,
      "id":"dev1",
      "credentials":{
        "email":"administrator@open.akana.com",
        "password":"password"
      }
    },
    {
      "name":"test1",
      "id":"test1",
      "address":"http://open.akana.com:9910",
      "consoleAddress":"http://open.akana.com:9910/atmosphere",
      "credentials":{
        "email":"administrator@open.akana.com",
        "password":"password"
      }
    }
  ]
}</pre>


<h3 id="dz_configurations">Deployment Zone Configurations</h3>
<p><strong>API Platform Version: 8.4.12 and later</strong></p>
<p>Within a promotion profile, deployment zone configurations can be used to tailor the propagation of an API's endpoints to the target environment. During API promotion, applicable deployment zone configurations are selected based on:</p>
<ul>
	<li>The name of an API endpoint's deployment zone in the source environment.</li>
	<li>Optionally, filters that apply to the metadata of the API.</li>
</ul>
<p>A deployment zone configuration contains a list of deployment zone names in the target environment. When a deployment zone configuration is determined to be applicable for an endpoint of the API being promoted, the endpoint is populated into the specified target environment deployment zones.</p>
<p><strong>Note</strong>: The target deployment zone must have a listener that matches the listener name of the endpoint. If necessary, use rules in the deployment zone configuration to adjust listener names.</p>
<p>The structure of the deployment zone configurations allows endpoints in a source environment to be fanned out to a target environment. For example, a staging environment might only support a single deployment zone while the production environment supports many deployment zones across different geographic regions.</p>
<p>Consider the following example PromotionProfile:</p>
<pre>{
  "name":"Default Production Promotion",
  "targetEnvironment":"production",
  "deploymentZoneConfigurations":[
    {
      "sourceDeploymentZoneName":"StagingDZ",
      "targetDeploymentZoneNames":[
        "ProdWestDZ",
        "ProdEastDZ"
      ]
    }
  ]
}</pre>
<p>In this example, a single deployment zone configuration has been defined to propagate endpoints in in the <strong>StagingDZ1</strong> deployment zone in the source environment to both <strong>ProdWestDZ</strong> and <strong>ProdEastDZ</strong> in the target environment.</p>


<h4 id="s06_01">Using Filters with deployment zone configurations
</h4><p>The filtering capability of deployment zone configurations allows for target deployment zones to be determined based on the metadata of the API. For example, security metadata associated with the API might determine the specific deployment zones that the API is deployed to.</p>
<p>In the following example, the filters named <strong>PII</strong> and <strong>Not PII</strong> are used in selecting the deployment zones an API's endpoints are propagated to in the target environment, based on whether the API is marked as processing personal identity information.</p>
<pre>"deploymentZoneConfigurations": [
  {
    "filterNames": [
      "pii"
    ],
    "sourceDeploymentZoneName": "StagingDZ",
    "targetDeploymentZoneNames": [
      "PIIDZ"
    ]
  },
  {
    "filterNames": [
      "not-pii"
    ],
    "sourceDeploymentZoneName": "StagingDZ",
    "targetDeploymentZoneNames": [
      "NotPIIDZ"
    ]
  }
]</pre>


<p>For the above example, the filters in the topology are defined as shown below.</p>
<pre>"filters": [
  {
    "name": "pii",
    "classifier-criteria": [
      {
        "classifierName": "pii",
        "values": [
          {
            "value": "true"
          }
        ]
      }
    ]
  },
  {
    "name": "not-pii",
    "classifier-criteria": [
      {
        "classifierName": "pii",
        "values": [
          {
            "value": "false"
          }
        ]
      }
    ]
  }
]
</pre>


<h4 id="s06_02">Default Endpoint Propagation</h4>
<p>If an endpoint's source deployment zone doesn't match a defined deployment zone configuration, the promotion processing will propagate the endpoint to a deployment zone in the target environment with the same name, if one exists. You can think of this as an implicit deployment zone configuration for every deployment zone in the source environment of the form:</p>
<pre>{
  "sourceDeploymentZoneName":"{source DeploymentZone name}",
  "targetDeploymentZoneNames":[
    "{source DeploymentZone name}"
  ]
}</pre>

<p>You can disable endpoints from a source deployment zone completely by defining a deployment zone configuration that specifies no target deployment zone names. For example:</p>
<pre>{
  "sourceDeploymentZoneName":"TestDZ",
  "targetDeploymentZoneNames":[

  ]
}</pre>



<h4 id="s06_03">Using Rules with deployment zone configurations
</h4><p>A deployment zone configuration can optionally contain RuleDefinitions to be applied to the properties of the endpoints being promoted with this deployment zone configuration.</p>
<p>At this level, you can use rules to alter a listener name, the endpoint's path, or its vanity host. The properties available for modification are:</p>
<dl>
	<dt>listenerName</dt>
	<dd>The name of the endpoint's listener; for example, <strong>http</strong>. It must match a listener associated with the target deployment zone.</dd>

	<dt>path</dt>
	<dd>The endpoint-specific path. If the endpoint in the source environment did not have an endpoint-specific path, this will be set to <strong>NO_VALUE</strong>. A rule can set the path property to another value, or to <strong>NO_VALUE</strong> indicating that the target endpoint will not have a specific path.</dd>

	<dt>vanityHostName</dt>
	<dd>A host name (CNAME) specific to the endpoint. If the endpoint in the source environment did not have a vanity host name, this will be set to <strong>NO_VALUE</strong>. A rule can set the vanityHostName property to another value, or to <strong>NO_VALUE</strong> which indicates that the target endpoint will not have a vanity host name.</dd>

	<dt>DISABLED</dt>
	<dd>This property provides a means of disabling an endpoint via a rule. If you set the value of DISABLED to <strong>true</strong>, the endpoint is not propagated to the target environment.</dd>
</dl>

<p>In the example shown below, a rule is provided with a deployment zone configuration that will disable the propagation of endpoints that do not have a vanity host name in the source environment.</p>
<pre>{
  "sourceDeploymentZoneName":"StagingDZ",
  "targetDeploymentZoneNames":[
    "ProdDZ"
  ],
  "rules":[
    {
      "scope":"vsep",
      "condition":"vsep.vanityHostName == 'NO_VALUE'",
      "action":"vsep.DISABLED = 'true'"
    }
  ]
}</pre>


<h4 id="s06_04">Duplicate Endpoints</h4>
<p>Care should be taken to avoid duplicating endpoints across environments using the same underlying Gateways. This situation can occur if the target deployment zone has the same underlying Gateway as the source deployment zone (leading to the same host name and port) and has no options set for altering the Gateway host name or path. This situation will result in the promotion of the API failing.</p>
<p>There are several ways you can help make sure there are no duplicate endpoints:</p>
<ul>
	<li>Enable random prefixes in the target deployment zone.</li>
	<li>Provide a custom hostname for the Gateway in the target deployment zone that differs from the source deployment zone.</li>
	<li>Use a rule in the deployment zone configuration to alter the vanity host name or path of the endpoints being promoted.</li>
</ul>
<p><a href="#top">Back to top</a></p>



<h3 id="s08_03_environment_config">Environment Configuration</h3>
<p>The <strong>configuration</strong> property of an Environment is used to customize behavior of assets, such as APIs, that are created or updated in the tenant that the environment is associated with. You can use an environment's configuration to define <strong>templating</strong> aspects of API implementations. This is similar to the behavior described in the section <a href="#runtime_config">Defaulting API Settings using Runtime Configurations</a>. This is because the environment configuration automates the creation of Runtime Configuration assets in the tenant library. Further information on the defaulting behavior described here can be found in that section.</p>
<p>The following is a complete example of an <strong>Environment Configuration</strong> definition.</p>
<pre>{
  "name": "development",
  "displayName": "Development",
  "description": "Development environment",
  "tenant": "DevelopmentTenant",
  "configuration": {
    "apiImplementationProfiles": [
      {
        "name": "Internal API Profile",
        "type": "Live",
        "filterNames": [
          "internal"
        ],
        "deploymentZones": [
          "DZ9941"
        ],
        "virtualServicePolicies": [
          {
            "policyName": "DetailedAuditing"
          }
        ],
        "virtualHost": "InternalHost.com",
        "path": "/{catalog_asset.name_normalized}",
        "allowAnonymousAccess": "true"
      },
      {
        "name": "External API Profile",
        "type": "Live",
        "filterNames": [
          "external"
        ],
        "deploymentZones": [
          "DZ9942"
        ],
        "virtualHost": "ExternalHost.com",
        "path": "/{catalog_asset.name_normalized}/external",
        "allowAnonymousAccess": "false",
        "approvalRequired": "true"
      }
    ]
  }
}</pre>


<h4 id="s08_04_api_impl_profiles">API Implementation Profiles </h4>
<p>A Configuration contains an <strong>apiImplementationProfiles</strong> collection. An <strong>apiImplementationProfile</strong> is used to define the defaults for all API Implementations in the tenant that match the type and filter of the apiImplementationProfile. In the example above, the apiImplementationProfile <strong>Internal API Profile</strong> will apply to the <strong>Live</strong> implementations of APIs whose custom properties match the <strong>internal</strong> filter (defined in the <strong>filters</strong> property of the topology), while the <strong>External API Profile</strong> will apply to <strong>Live</strong> implementations of APIs that match the <strong>external</strong> filter. Note that the two options for the <strong>type</strong> property are <strong>Live</strong> and <strong>Sandbox</strong>.</p>
<p>An <strong>apiImplementationProfile</strong> collection can specify:</p>
<ul>
	<li>The Deployment Zones that an API Implementation is to be deployed to:
		<p>Specify the deployment zone names in the <strong>deploymentZones</strong> property (for additional details, see <a href="#dz_config">Deployment Zone Configuration</a>.</p></li>
	<li>The policies that are to be applied to the Implementation:
		<p>Specify either the <strong>policyName</strong> or <strong>policyId</strong> for each policy to be applied.</p></li>
	<li>The policies that are to be applied to the physical service of a proxy Implementation (not shown in example above):
		<p>Specify either the <strong>policyName</strong> or <strong>policyId</strong> for each policy to be applied within a <strong>physicalServicePolicies</strong> property.</p></li>
	<li>The virtual host for the implementation's endpoints:
		<p>Specify using the <strong>virtualHost</strong> property.</p></li>
	<li>The path for the implementation's endpoints:
		<p>Specify using the <strong>path</strong> property.</p></li>
	<li>Whether the API implementation allows anonymous access:
		<p>Specify in the Boolean <strong>allowAnonymousAccess</strong> property.</p></li>
	<li>Whether access to the API implementation requires approval:
		<p>Specify in the Boolean <strong>requiresApproval</strong> property.</p></li>
	<li>Whether debug mode should be enabled for the API implementation (not shown in example above):
		<p>Specify in the Boolean <strong>debugModeEnabled</strong> property.</p></li>
</ul>
<p><a href="#top">Back to top</a></p>

<h5 id="dz_config">Deployment Zone Configuration</h5>
<p>The <strong>deploymentZones</strong> property of an <strong>apiImplementationProfile</strong> is used to specify which deployment zones and optionally which listeners within a deployment zone should support an API's endpoints. In the simplest case, a deployment zone can be specified with no additional details, as in this example:</p>
<pre>{
  "name" : "DZ9941"
}</pre>
<p>In this example, APIs that are using this apiImplementationProfile will be deployed to all listeners within the designated deployment zone.</p>
<p>The following example goes a step further and specifies a specific listener within the deployment zone that should be used:</p>
<pre>{
  "name": "DZ9941",
  "listeners": [
    {
      "name": "default-http0"
    }
  ]
}</pre>
<p>Additionally, listener-specific settings can be defined as in this example:</p>
<pre>{
  "name": "DZWest",
  "listeners": [
    {
      "name": "default-http",
      "public": "false",
      "virtualHost": "listenerscopedhost",
      "path": "listenerscopedpath"
    },
    {
      "name": "default-https",
      "useImplementationKeyforSSL": "true"
    }
  ]
}</pre>
<p>In this case, two listeners were specified within the DZWest deployment zone. Endpoints deployed in the <strong>default-http</strong> listener will:</p>
<ul>
	<li>Be set to private.</li>
	<li>Use a listener-specific host name (which overrides the <strong>virtualHost</strong> property set in the <strong>apiImplementationProfile</strong>).</li>
	<li>Use a listener-specific path (which overrides the <strong>path</strong> property set in the <strong>apiImplementationProfile</strong>).</li>
</ul>
<p>Endpoints deployed in the <strong>default-https</strong> listener are set to use the API Implementation's Key/Certificate for SSL, but will be public by default and will use the <strong>virtualHost</strong> and <strong>path</strong> of the containing <strong>apiImplementationProfile</strong> (if <strong>virtualHost</strong> and <strong>path</strong> are specified).</p>
<p><strong>Note</strong>: If a deployment zone configuration results in a duplicate endpoint being produced, that endpoint will be omitted from the API.</p>

<h5 id="replacement_parms">Replacement Parameters</h5>
<p>A limited number of replacement parameters are available for use in setting the <strong>virtualHost</strong> and <strong>path</strong> properties at the apiImplementationProfile and listener level of an Environment configuration. To use these parameters, specify the parameter name within braces <strong>{&lt;parameter&gt;}</strong> within either the <strong>virtualHost</strong> or <strong>path</strong> properties. For example:</p>
<pre>"path" : "{api.name_normalized}_{api.version_normalized}"</pre>
<p>At runtime, the platform replaces these parameters with information from the API. In the above example, an API with name <strong>CurrencyConverter</strong> and version <strong>1</strong> would result in a path of <strong>currencyconverter_1</strong>.</p>
<p>The following replacement parameters are currently available:</p>
<ul>
	<li><strong>api.name</strong>
<p>The actual name of the API.</p></li>
	<li><strong>api.version</strong>
<p>The actual version of the API.</p></li>
	<li><strong>api.name.normalized</strong>
<p>The api name, normalized for use as an NM token.</p></li>
	<li><strong>api.version.normalized</strong>
<p>The api version, normalized for use as an NM token.</p></li>
	<li><strong>api.physical_url_path.live</strong>
<p>The path of the first physical endpoint for the live implementation of the API. This is only applicable when the API implementation is using the proxy pattern.</p></li>
	<li><strong>api.physical_url_path.sandbox</strong>
<p>The path of the first physical endpoint for the sandbox implementation of the API. This is only applicable when the API implementation is using the proxy pattern.</p></li>
	<li><strong>api.property</strong>
<p>The value of the specified custom API property. For example, if an API has the property <strong>classification</strong> set to <strong>restricted</strong>, the parameter <strong>{api.property.classification}</strong> will resolve to <strong>restricted</strong>.</p></li>
</ul>
<p><strong>Note</strong>: A parameter that cannot be resolved or is not recognized will remain in the unresolved form.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="topology_api">Topology API</h3>
<p>In this section:</p>
<ul>
	<li>Finding the Topology API Documentation</li>
	<li>Using the Topology API</li>
</ul>


<h4 id="topologyapi_01">Finding the Topology API Documentation</h4>
<p>You can find the Topology API documentation in the following locations:</p>
<ul>
	<li>In your deployment:
		<ul>
			<li>Once the Lifecycle Coordinator feature is deployed, a REST API for maintaining topologies is available from the path <strong>/lc/api/topologies</strong> relative to the container's URL. For example:
			<p><strong>http://myHost:9900/lc/api/topologies</strong></p></li>
			<li>You can find Swagger documentation for this API in the container deployment:
			<p><strong>$INSTALL_DIR/docs/restApiDocs/api-platform/swagger-Topology_API.html</strong></p></li>
		</ul>
	</li>
	<li>On the <a href="../../ag/assets/0804_api_plat/restApiDocs/api-platform/api-urn_com.akana.lifecyclecoordinator.rest-TopologyAPI.html" title="Topology API on Akana docs site">Akana docs site</a>.</li>
</ul>


<h4 id="topologyapi_02">Using the Topology API</h4>
<p>The first step is to create a Topology. This is done by POST-ing the complete Topology JSON document to <strong>...lc/api/topologies</strong>. This can be done programmatically or with a browser plugin such as Firefox RESTClient:</p>
<p><img src="images/promotion_10.jpg" alt="Creating the topology" /></p>
<p>Note the inclusion of the content-type and basicAuth headers.</p>
<p>Updates to the topology can be performed on the topology as a whole, or on specific properties within the document. For example, the Rules for a PromotionProfile can be updated with a PUT of an array of Rules such as:</p>
<pre>[
  {
    "scope":"psep",
    "condition":"psep.url.indexOf(\"foo.com\") > 0",
    "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
  }
]</pre>
<p>To:</p>
<pre>http://myHost:9900/lc/api/topologies/{topology-name}/environments/{environment-name}/profiles/{promotionProfile-name}/rules</pre>
<p><a href="#top">Back to top</a></p>



<h3 id="lm_console">Lifecycle Manager Console</h3>
<p>The Lifecycle Manager (<strong>LM</strong>) console is useful for accessing promoted assets and their iterations as well as approving promotion requests. Within Lifecycle Manager, a topology is represented as a <strong>library</strong> and the elements of a Topology along with the entities being promoted are represented as <strong>assets</strong>.</p>


<h4 id="s07_01">Logging In</h4>
<p>The first step is to log in to the library that corresponds with the topology. There are two options:</p>
<ul>
	<li>If the admin user password has been set, you can log into the library as the Lifecycle Repository super user at the URL below:
		<pre>{container-base-url}/lm/application/access/suLogin.do</pre></li>
	<li>If the topology was configured to delegate authentication to a local tenant, you can log in at the URL below, using the tenant email and password for a user in the designated local tenant:
	<pre>{container-base-url}/lm/application/access/challenge.do</pre></li>
</ul>


<h4 id="s07_02">Viewing Assets and Iterations</h4>
<p>The left pane of the LM console contains a search box which can be used for finding assets by name:</p>
<p><img src="images/promotion_11.jpg" alt="Finding assets by name" /></p>
<p>The search results include separate LM assets for each environment to which a promotable entity has been promoted or is pending promotion. Clicking on an asset in the search results brings up a details page:</p>
<p><img src="images/promotion_12.jpg" alt="Published asset, Details page" /></p>
<p>In this case, the <strong>Current Iteration</strong> relationship is referencing the third iteration of this API asset. Click on the iteration asset name to view details about the iteration, as shown below.</p>
<p><img src="images/promotion_13.jpg" alt="Iteration details" /></p>
<p>Here you can see the following details for this iteration:</p>
<ul>
	<li>The time the iteration was promoted</li>
	<li>The user who requested the promotion</li>
	<li>The status of the promotion</li>
	<li>The actual archive.zip (after rule processing) that was imported into the target environment</li>
	<li>The response from the Import</li>
	<li>A relationship to the previous iteration for this environment</li>
	<li>A relationship to the source iteration in the previous environment</li>
	<li>A relationship to the PromotionProfile that was used to promote the iteration</li>
</ul>
<p>Additionally, in the case of a promotion failure (generally due to an invalid rule) error details are stored in the Artifacts section of the iteration asset:</p>
<p><img src="images/promotion_14.jpg" alt="Error details" /></p>

<h4 id="s07_03">Promotion Requests</h4>
<p>The configuration of the topology library can optionally be customized to require approvals for a promotion request. For assistance with customization, contact Akana Professional Services.</p>
<p>In this scenario, a user with the required authorization role has a pending request notification message in the left pane after logging into the LM console:</p>
<p><img src="images/promotion_15.jpg" alt="Pending requests" /></p>
<p>Clicking on the details for that request allows the user to approve the request:</p>
<p><img src="images/promotion_16.jpg" alt="Approving a pending request" /></p>
<p>Clicking <strong>approve</strong> allows the promotion to succeed or proceed to the next role approval.</p>
<h5>Rejecting Requests</h5>
<p>A user may choose to reject the request by clicking on <strong>rejection properties</strong> and then clicking <strong>reject</strong>. In this case, the Iteration asset remains in a <strong>Promotion Pending</strong> state, however, the API Platform UI shows the state of the promotion as <strong>Promotion Rejected</strong> and allows the promotion to be requested again.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="env_decoupled_00">Support for Decoupled Environments in a Topology</h3>
<p>In a standard topology, Lifecycle Coordinator communicates directly with the environments in the topology to:</p>
<ul>
	<li>Periodically retrieve context information for the environment (read).</li>
	<li>Import a promoted asset to the environment (write).</li>
</ul>
<p>However, in some situations, an environment (generally a production environment) might be physically isolated from Lifecycle Coordinator and other internal systems for security purposes.</p>
<p>Lifecycle Coordinator supports this scenario by allowing tenants to be designated as not connected. This is done using the <strong>connected</strong> property, as in this example tenant definition:</p>
<pre>{
  "name": "ProductionTenant",
  "id": "prod",
  "connected" : "false"
}</pre>
<p>In the case where a tenant is marked as not connected, only the tenant's name and id must be specified. Credentials and address are omitted, since Lifecycle Coordinator does not communicate with that tenant.</p>
<p>When a tenant is marked as not connected, Lifecycle Coordinator assumes that it is on a remote system and that the <strong>preserve-keys</strong> mode is applicable.</p>
<p>Normally, a tenant that is not connected is the final environment in the promotion path.</p>
<p>Because Lifecycle Coordinator cannot communicate directly with a tenant that is not connected, some external system or user must facilitate the exchange of data between Lifecycle Coordinator and the decoupled tenant. The two scenarios are:</p>
<ul>
	<li><a href="#env_decoupled_01">Updating Environment Context information</a></li>
	<li><a href="#env_decoupled_02">Promoting Assets</a></li>
</ul>
<h4 id="env_decoupled_01">Updating Environment Context information</h4>
<p>Lifecycle Coordinator needs to have some understanding of the target environment supported by a decoupled tenant so that it can validate for the existence of dependencies when an asset is promoted to that environment. To accomplish this, the promotion context information must be fetched from the decoupled tenant with a GET call to the <strong>getEnvironmentPromotionContext</strong> operation of the TenantAdministrationAPI on the isolated system.</p>
<pre>{host:port}/api/tenants/{tenant id}/{environment name}/promotion/context?includeServiceInfo=true&amp;includeAPIInfo=true</pre>
<p>Content-type is application/json.</p>
<p>For example:</p>
<pre>GET http://tenant3:9940/api/tenants/tenant3/production/promotion/context?includeServiceInfo=true&amp;includeAPIInfo=true</pre>
<p>The resulting JSON document can then be passed as the request body to the TopologyAPI <span class="apidoc_code"><strong>updateEnvironmentContext</strong></span> method on the Lifecycle Coordinator system using a PUT call to:</p>
<pre>{host:port}/lc/api/topologies/Topology1/environments/{environment name}/context</pre>
<p>For example:</p>
<pre>PUT http://localhost:9920/lc/api/topologies/Topology1/environments/production/context</pre>
<p>This process should be repeated when any relevant context information in the decoupled environment changes. For example, a new policy or organization is added in the decoupled tenant.</p>


<h4 id="env_decoupled_02">Promoting Assets</h4>
<p>Since Lifecycle Coordinator cannot directly call the import API on the decoupled tenant, you'll need to take some extra steps to promote to that environment.</p>

<h5>To promote assets for a decoupled tenant</h5>
<ol>
	<li>Request promotion of the API to the decoupled environment in the normal way, using the API Platform user interface or via the TopologyAPI promote operation (see <a href="../../ag/assets/0804_api_plat/restApiDocs/api-platform/api-urn_com.akana.lifecyclecoordinator.rest-TopologyAPI.html" title="Link to generated Topology API doc" target="_blank">Topology API</a>).
<p>When the promotion is complete, the status of the asset for the decoupled environment shows as <strong>promoted</strong>. In this case, the <strong>promoted</strong> status indicates that all processing of the archive has been completed and the archive is ready for importing into the target environment.</p></li>
	<li>Use the <strong>getPackage</strong> method in the TopologyAPI to retrieve the processed import package from Lifecycle Coordinator:
		<pre>GET {host:port}/lc/api/topologies/{topology-name}/environments/{environment-name}/assets/{asset-id}/package</pre>
		<p>In this operation, {asset-id} is either an API version ID or App version ID. For example:</p>
		<pre>GET http://localhost:9920/lc/api/topologies/Topology1/environments/production/assets/ffc4ba19-c5cb-4e9d-ae39-78ab6e0efc84.tenant1/package</pre>
		<p>This returns the archive as a ZIP file.</p></li>
	<li>On the isolated system, upload the archive ZIP file to the decoupled tenant in one of these ways:
		<ul>
			<li>Via the import wizard in the API Platform UI: see <a href="../learnmore/bus_admin_export_import.htm#import_org_app_api">How do I import site, app, or API information from an export file?</a></li>
			<li>By using the importPackage operation on the TenantAdministrationAPI: see <a href="../api/tenantadmin/m_tenantadmin_importPackage.htm"><span class="apidoc_code">POST /api/tenants/{TenantFedMemberID}/packages</span></a>.</li>
		</ul>
	</li>
</ol>
<p><a href="#top">Back to top</a></p>



<h3 id="runtime_config">Defaulting API Settings using Runtime Configurations (8.4.17 and later)</h3>
<p>The Runtime Configuration section which was previously in the Promotion Guide is now in a separate document with other content relating to custom properties.</p>
<p>Runtime Configuration is not part of Lifecycle Coordinator, but can be used to augment the capabilities of Lifecycle Coordinator to further tailor the configuration of APIs within each environment of a topology.</p>
<p>For details, see <a href="../lr/lr_runtime_config.htm">Defaulting API Settings using Runtime Configurations</a> (Lifecycle Repository documentation).</p>
<p><a href="#top">Back to top</a></p>



<h3 id="s09_orchestrated">Appendix A: Promoting Orchestrated APIs</h3>
<p><strong>API Platform Version: 2018.0.0 and later</strong></p>
<p>Unlike a standard proxy-pattern API, APIs implemented as orchestrations could have dependencies on scripts, processes, or services not contained within the API itself. When promotion is requested for an orchestrated API, all such external dependencies are checked to make sure they exist in the target environment. If there are unmet dependencies, the promotion is aborted and a notification specifying the unmet dependencies is provided to the user.</p>
<p>In the case of external scripts and processes, the promotion process attempts to match the referenced script or process in the target environment based on the key of the object.</p>
<p>Mapping of processes and scripts between environments can be specified within a Promotion Profile using the <strong>processMappings</strong> and <strong>scriptMappings</strong> properties respectively. The <strong>processMappings</strong> and <strong>scriptMappings</strong> properties allow you to correlate source and target scripts/processes either by ID or by name.</p>
<p>This section includes the following examples of defining process and script mappings:</p>
<ul>
	<li><a href="#s09_01">By using IDs</a></li>
	<li><a href="#s09_02">By using names</a></li>
	<li><a href="#s09_02">By using</a><a href="#s09_03"> the <strong>match-processes-by-name</strong> and <strong>match-scripts-by-name</strong> properties on the Promotion Profile</a></li>
</ul>

<h5 id="s09_01">
Defining process and script mappings by using IDs</h5>
<p>In the example Promotion Profile below, processes and script mappings are defined using IDs.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "scriptMappings":[
    {
      "sourceScript" : {"scriptId" : "script:7f4fbb16-8389-11e8-af80-80b01a868d88"},
      "targetScript" : {"scriptId" : "script:fb51d840-8399-11e8-af80-80b01a868d88"}
    }
  ],
  "processMappings":[
    {
      "sourceProcess" : {"processId" : "bpel:8c862595-8389-11e8-af80-80b01a868d88"},
      "targetProcess" : {"processId" : "bpel:b2ad95b6-839b-11e8-af80-80b01a868d88"}
    }
  ]
}</pre>

<h5 id="s09_02">Defining process and script mappings by using names</h5>
<p>In the example below, processes and script mappings are defined by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "targetEnvironment": "production",
  "scriptMappings":[
    {
      "sourceScript" : {"scriptName" : "Dev Script A"},
      "targetScript" : {"scriptName" : "Prod Script A"}
    }
  ],
  "processMappings":[
    {
      "sourceProcess" : {"processName" : "Dev Process A"},
      "targetProcess" : {"processName" : "Prod Process A"}
    }
  ]
}
</pre>

<h5 id="s09_03">Defining process and script mappings by using the match-processes-by-name and match-scripts-by-name properties on the Promotion Profile</h5>
<p>Optionally, the properties <strong>match-processes-by-name</strong> and <strong>match-scripts-by-name</strong> can be set on the Promotion Profile, to allow the promotion logic to map referenced scripts or processes based on the name rather than the key of the object. For example, the example below shows a Promotion Profile allowing matching of both processes and scripts by name.</p>
<pre>{
  "name": "Default Production Promotion",
  "description": "Dev to production default profile",
  "targetEnvironment": "production",
  "properties" : [
    {"name":"match-scripts-by-name","value":"true"},
    {"name":"match-processes-by-name","value":"true"}
  ]
}
</pre>

<h4 id="s09_01_referenced_svcs">Referenced Services</h4>
<p>An orchestration of an API operation might use invocation actions to call out to other services. Such invocations specify the target service, operation, and endpoint to use in the invocation. The target service of an invocation must exist in the target environment prior to promoting the orchestrated API. There are two scenarios:</p>
<ul>
	<li><strong>Remote tenants, where keys are preserved across environments</strong>: A service with a matching key must already exist in the target environment.</li>
	<li><strong>Local tenants, where keys are mapped across environments</strong>: The API containing the target service must have been previously promoted using Lifecycle Coordinator.</li>
</ul>
<p>The most common case of service invocation is a call to a physical service. Often, the URL of a physical service is modified for use in the target environment using rules in the Promotion Profile. In this case, the URL of the endpoint of the invocation should be similarly modified. The following example shows the rules that would be defined in a Promotion Profile for changing the host name of physical service URLs along with the invocation references (using the <strong>serviceRef</strong> scope).</p>
<pre>"rules": [
  {
    "scope":"psep",
    "condition":"psep.url.indexOf(\"foo.com\") > 0",
    "action":"psep.url = psep.url.replace(\"foo.com\",\"bar.com\")"
  },
  {
    "scope":"serviceRef",
    "condition":"serviceRef.url.indexOf(\"foo.com\") > 0",
    "action":"serviceRef.url = serviceRef.url.replace(\"foo.com\",\"bar.com\")"
  }
]
</pre>
<p><a href="#top">Back to top</a></p>



<h3 id="app_b_client_apps">Appendix B: Support for client apps</h3>
<p><strong>API Platform Version: 2018.0.0 and later</strong></p>
<p>Currently, the API Platform allows contracts to be established between apps and APIs, but does not support direct API to API access. This can be mitigated through the use of a pattern where an API is represented with a <strong>client App</strong>. With this approach, each API has an accompanying client app that is used to establish access to other APIs for the represented API. Contracts between a client app and another API are logically contracts between the source and target APIs, allowing for full dependency analysis of composite APIs.</p>
<p>You can configure the API Platform Repository plug-in to support the client app pattern by adding the <strong>Create Client App</strong> task to the post-processing phase of the API submission process. For additional information about configuring a submission process, contact Rogue Wave Technical Support. This task will cause a client app to be created as each API is created. The client app will be named as <strong>{api name}_app</strong> and a <strong>client-app</strong> property will be set on the represented API pointing to the client app. The generated client app will, in turn, have a <strong>represented-api</strong> property to point back to the API.</p>
<p>Note that the <strong>Create Client App</strong> task can be configured to run based on the setting of a custom property on the API, such as <strong>isConsumer</strong>, allowing the creator of the API to determine whether a client app is needed.</p>


<h4 id="app_b_promotion_support">Promotion Support</h4>
<p>When an API with an accompanying client app is promoted using Lifecycle Coordinator, the client app will also be promoted to the target environment as well as any contracts it has to other APIs. These contracts will be validated prior to API promotion in the same manner as the dependencies for a standard app are validated prior to app promotion.</p>
<p><a href="#top">Back to top</a></p>



<h3 id="app_c_tips">Appendix C: Promotion tips and best practices</h3>
<p>When making changes to an asset in the hierarchy, always make changes in the Dev environment (or whichever environment is first in the promotion chain). If you make changes in a later environment, they will be lost on a subsequent iteration.</p>
<p><a href="#top">Back to top</a></p>